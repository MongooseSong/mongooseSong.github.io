<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Song from A Mongoose</title>
  <subtitle>I wanna to discover everything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mongoosesong.github.io/"/>
  <updated>2017-08-15T06:11:08.000Z</updated>
  <id>https://mongoosesong.github.io/</id>
  
  <author>
    <name>mongoose</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript元编程</title>
    <link href="https://mongoosesong.github.io/2017/08/15/js-metaprog/"/>
    <id>https://mongoosesong.github.io/2017/08/15/js-metaprog/</id>
    <published>2017-08-15T06:06:58.000Z</published>
    <updated>2017-08-15T06:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近稍微花了点时间，抛开业务研究了一下技术。这里结合之前学习过Java的一点经验，简单的谈一下元编程。</p>
<h4 id="1-何谓元编程"><a href="#1-何谓元编程" class="headerlink" title="1.何谓元编程"></a>1.何谓元编程</h4><p>元编程简单说就是“编写代码的代码”，换个高雅解释即是“元编程是编写在运行时操纵语言构件的代码”。</p>
<p>估计还是有人没看懂，这里再换一种说法解释：<strong>”一门语言拥有对自身的元编程能力就表现在反射“</strong>。大家应该都知道了吧。</p>
<p>用过Java的都知道反射的好处，它提供了在代码运行阶段动态执行代码的可能。反射和代理可以结合起来使用使得代码更富于动态性。举个例子，常见的Web框架如Spring、Struts等，都是以XML的方式让开发者动态配置执行类和执行方法，在运行期间，再通过反射和代理的方式运行代码。</p>
<p>有人说，JavaScript本身就是动态语言，为何还要强调元编程呢，不要急，请看我慢慢道来。</p>
<h4 id="2-JavaScript的代理模式"><a href="#2-JavaScript的代理模式" class="headerlink" title="2.JavaScript的代理模式"></a>2.JavaScript的代理模式</h4><p>在ES6中，引入了代理类，具体细节不多说，这里只描述一下重点。<br>常见的代理是如此写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = new Proxy(被代理的对象, &#123;</div><div class="line">  get: function (target, key, receiver) &#123;</div><div class="line">    // 返回被代理修改过的值</div><div class="line">    return ...</div><div class="line">  &#125;,</div><div class="line">  set: function (target, key, value, receiver) &#123;</div><div class="line">    // 通过此方法拦截修改值</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.a = 1; // invoke set function</div><div class="line">console.log(obj.b) // invoke get function</div></pre></td></tr></table></figure>
<p>常见的Proxy拦截的目标列表如下：</p>
<ul>
<li><code>get</code> 拦截对象属性的读取</li>
<li><code>set</code> 拦截对象属性的设置</li>
<li><code>has</code> 拦截对 in 的操作</li>
<li><code>delete</code> 拦截对 delete 的操作</li>
<li><code>ownKeys</code> 主要拦截Object.keys 方法</li>
<li><code>apply</code> 拦截所有主动调用方法，直接调用、call、apply都会被拦截</li>
<li><code>construct</code> 拦截 new 操作<br>还有 <code>getOwnPropertyDescriptor</code>、<code>defineProperty</code>、<code>preventExtensions</code>、<code>getPrototypeOf</code>、<code>isExtensible</code>、<code>setPrototypeOf</code>都是对同名的方法进行拦截。</li>
</ul>
<h4 id="3-JavaScript的反射"><a href="#3-JavaScript的反射" class="headerlink" title="3. JavaScript的反射"></a>3. JavaScript的反射</h4><p>JavaScript作为一门动态语言，本身其实已经支持了类似Java的Reflect方法，不过在ES6中，仍然提供了Reflect这个反射类。</p>
<p>本身Reflect不会提供新功能，官方指出，提供Reflect主要目的有以下几点：</p>
<ol>
<li>是把ES5中类似Object.defineProperty的方法移入Reflect中</li>
<li>是重构一些Object已有的方法，使得参数和返回值理解起来更加合理。</li>
<li>通过Reflect的方式替换掉 in 和 delete 的操作符</li>
<li><strong>搭配Proxy，无论通过Proxy怎么设置行为，都可以通过Reflect下相应方法来执行原生方法。</strong><br>举个例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var handlers = &#123;</div><div class="line">  get(target,key,context) &#123;</div><div class="line">    console.log( &quot;accessing: &quot;, key );</div><div class="line">    // 这里通过Reflect.get来获取真正的值，不然是循环引用了</div><div class="line">    return Reflect.get(</div><div class="line">      target, key, context</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>值得留意的一点是，Reflect.ownKeys是一定按照顺序列出可枚举的属性的，顺序如下：<br>i. 首先，如果索引是整数，升序。<br>ii. 其次，根据来根据索引String创建排序。<br>iii. 最后，根据Symbol创建顺序。<br>在 ES6 中，<code>Reflect.ownKeys(..)</code>，<code>Object.getOwnPropertyNames(..)</code>，<code>Object.getOwnPropertySymbols(..)</code>的顺序是可靠可预测的，因此它是安全的。</p>
<h3 id="4-JavaScript元编程"><a href="#4-JavaScript元编程" class="headerlink" title="4. JavaScript元编程"></a>4. JavaScript元编程</h3><p>刚才所列举的，Proxy和Reflect都是在元级别进行自定义行为（比如属性查找，赋值，枚举，函数调用等），这里也顺便强调一下<strong>包装</strong>和<strong>代理</strong>之间的区别，简单的理解起来，<strong>包装</strong>是新增，<strong>代理</strong>是修改。</p>
<p>这里举一个例子说明一下元编程几个简单的示例：  </p>
<h4 id="1-没有找到这样的属性或者方法"><a href="#1-没有找到这样的属性或者方法" class="headerlink" title="1. 没有找到这样的属性或者方法"></a>1. 没有找到这样的属性或者方法</h4><p>我们访问JavaScript对象的某一个属性，有可能因为拼写错误或者不确定是否为空，需要先判断。这里可以通过元编程的方式给出友善的提醒，或者直接赋上一个默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        a: 1,</div><div class="line">    &#125;,</div><div class="line">    handlers = &#123;</div><div class="line">        get(target,key,context) &#123;</div><div class="line">            if (Reflect.has(target, key)) &#123;</div><div class="line">                return Reflect.get(</div><div class="line">                    target, key, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                throw &quot;No such property/method!&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        set(target,key,val,context) &#123;</div><div class="line">            if (Reflect.has(target, key)) &#123;</div><div class="line">                return Reflect.set(</div><div class="line">                    target, key, val, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                throw &quot;No such property/method!&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    pobj = new Proxy( obj, handlers );</div><div class="line"></div><div class="line">pobj.a = 3;	// 没问题</div><div class="line"></div><div class="line">pobj.b = 4;  // Error: No such property/method!</div><div class="line">pobj.bar();  // Error: No such property/method!</div></pre></td></tr></table></figure>
<h4 id="2-多重继承"><a href="#2-多重继承" class="headerlink" title="2. 多重继承"></a>2. 多重继承</h4><p>我们可以通过指定Symbol的方式，搭配get方法实现多重继承的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &quot;obj-1&quot;,</div><div class="line">        foo() &#123;</div><div class="line">            console.log( &quot;obj1.foo:&quot;, this.name );</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">    obj2 = &#123;</div><div class="line">        name: &quot;obj-2&quot;,</div><div class="line">        foo() &#123;</div><div class="line">            console.log( &quot;obj2.foo:&quot;, this.name );</div><div class="line">        &#125;,</div><div class="line">        bar() &#123;</div><div class="line">            console.log( &quot;obj2.bar:&quot;, this.name );</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    handlers = &#123;</div><div class="line">        get(target,key,context) &#123;</div><div class="line">            if (Reflect.has( target, key )) &#123;</div><div class="line">                return Reflect.get(</div><div class="line">                    target, key, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            // 核心在这里，强制get方法查找原型链数组里面的方法</div><div class="line">            else &#123;</div><div class="line">                for (var P of target[</div><div class="line">                    Symbol.for( &quot;[[Prototype]]&quot; )</div><div class="line">                ]) &#123;</div><div class="line">                    if (Reflect.has( P, key )) &#123;</div><div class="line">                        return Reflect.get(</div><div class="line">                            P, key, context</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    obj3 = new Proxy(</div><div class="line">        &#123;</div><div class="line">            name: &quot;obj-3&quot;,</div><div class="line">            baz() &#123;</div><div class="line">                this.foo();</div><div class="line">                this.bar();</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        handlers</div><div class="line">    );</div><div class="line"></div><div class="line">// 创建自定义的原型链</div><div class="line">obj3[ Symbol.for( &quot;[[Prototype]]&quot; ) ] = [</div><div class="line">    obj1, obj2</div><div class="line">];</div><div class="line"></div><div class="line">obj3.baz();</div></pre></td></tr></table></figure>
<h4 id="3-转变链式操作"><a href="#3-转变链式操作" class="headerlink" title="3. 转变链式操作"></a>3. 转变链式操作</h4><p>通过Proxy的get方法，我们可以把函数执行变成链式的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var pipe = (function () &#123;</div><div class="line">  return function (value) &#123;</div><div class="line">    var funcStack = [];</div><div class="line">    var oproxy = new Proxy(&#123;&#125; , &#123;</div><div class="line">      get : function (pipeObject, fnName) &#123;</div><div class="line">        if (fnName === &apos;get&apos;) &#123;</div><div class="line">          return funcStack.reduce(function (val, fn) &#123;</div><div class="line">            return fn(val);</div><div class="line">          &#125;,value);</div><div class="line">        &#125;</div><div class="line">        funcStack.push(window[fnName]);</div><div class="line">        return oproxy;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return oproxy;</div><div class="line">  &#125;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">var double = n =&gt; n * 2;</div><div class="line">var pow    = n =&gt; n * n;</div><div class="line">var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;</div><div class="line"></div><div class="line">pipe(3).double.pow.reverseInt.get; // 63</div></pre></td></tr></table></figure>
<h4 id="4-使用负值获取数组成员"><a href="#4-使用负值获取数组成员" class="headerlink" title="4. 使用负值获取数组成员"></a>4. 使用负值获取数组成员</h4><p>有些数组方法允许你通过 -1 获取数组最后一个元素，倒数第二个通过 -2 ，我们可以通过重写get方法实现这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function createArray(...elements) &#123;</div><div class="line">  let handler = &#123;</div><div class="line">    get(target, propKey, receiver) &#123;</div><div class="line">      let index = Number(propKey);</div><div class="line">      if (index &lt; 0) &#123;</div><div class="line">        propKey = String(target.length + index);</div><div class="line">      &#125;</div><div class="line">      return Reflect.get(target, propKey, receiver);</div><div class="line">     &#125;</div><div class="line">  &#125;;</div><div class="line">  // 把数组用 proxy 包裹一层</div><div class="line">  let target = [];</div><div class="line">  target.push(...elements);</div><div class="line">  return new Proxy(target, handler);</div><div class="line">&#125;</div><div class="line">let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</div><div class="line">console.log(arr[-1]); // c</div></pre></td></tr></table></figure>
<p>其他还有各种各样的用法，比如数据绑定、Http Mock、记录日志和执行时间等等，甚至是用纯JS实现DOM。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过ES6的Proxy和Reflect，我们可以实现很多可能性，当然部分还是处于实践中的状态，有问题或者更好的想法，欢迎大家一起来探讨研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近稍微花了点时间，抛开业务研究了一下技术。这里结合之前学习过Java的一点经验，简单的谈一下元编程。&lt;/p&gt;
&lt;h4 id=&quot;1-何谓元编程&quot;&gt;&lt;a href=&quot;#1-何谓元编程&quot; class=&quot;headerlink&quot; title=&quot;1.何谓元编程&quot;&gt;&lt;/a&gt;1.何谓元编
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用TypeScript集成React</title>
    <link href="https://mongoosesong.github.io/2017/06/13/react-typescript/"/>
    <id>https://mongoosesong.github.io/2017/06/13/react-typescript/</id>
    <published>2017-06-13T12:31:13.000Z</published>
    <updated>2017-06-13T12:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Webpack项目添加TypeScript支持"><a href="#一、Webpack项目添加TypeScript支持" class="headerlink" title="一、Webpack项目添加TypeScript支持"></a>一、Webpack项目添加TypeScript支持</h3><ol>
<li><p>安装npm包 </p>
<pre><code>tnpm i --save  @types/react @types/react-dom
tnpm i --save-dev ts-loader
</code></pre></li>
</ol>
<ol>
<li><p>webpack配置文件，添加对后缀名的识别</p>
<pre><code>resolve: {
    extensions: [&apos;&apos;, &apos;.webpack.js&apos;, &apos;.web.js&apos;, &apos;.ts&apos;, &apos;.tsx&apos;, &apos;.js&apos;]
  }
</code></pre></li>
</ol>
<ol>
<li><p>webpack添加loader，添加对ts和tsx文件的解析</p>
<pre><code>loaders: [{
        test: /\.tsx?$/,
        loader: &apos;ts-loader&apos;
  }],                  
</code></pre></li>
</ol>
<ol>
<li><p>项目根路径下添加tsconfig.json文件，配置项参见<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="external">官方文档</a></p>
<p> 这里直接不劳而获的贴出网上流行的内容：</p>
<pre><code>{
  &quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;./build/&quot;,
    &quot;sourceMap&quot;: true,
    &quot;noImplicitAny&quot;: true,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;target&quot;: &quot;es5&quot;,
    &quot;jsx&quot;: &quot;react&quot;
  },
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ]
} 
</code></pre></li>
</ol>
<ol>
<li>在这之后，可以在项目中直接写 ts 或者 tsx 文件了，会和其他的jsx文件一同以es5的形式被编译到pages文件里面。    </li>
</ol>
<h3 id="二、VSCODE集成ESLint和TSLint"><a href="#二、VSCODE集成ESLint和TSLint" class="headerlink" title="二、VSCODE集成ESLint和TSLint"></a>二、VSCODE集成ESLint和TSLint</h3><p>其实之前我IDE一直用的Webstorm，直到某一天项目再也打不开了……<br>VSCode一个好处是比Webstorm轻，没有很多不需要的功能，不像Webstorm需求的内存那么大，另外一点是很多必备的功能（如原生支持JSX、ES6等）都已经集成了，而且插件库来说还是比较全的。  </p>
<ul>
<li>支持<code>ESLint</code></li>
</ul>
<p>只需要安装<code>ESLint</code>这个插件即可。工程下已经有相应的.eslintrc文件和devDependencies了。</p>
<ul>
<li>支持<code>TSLint</code></li>
</ul>
<p><code>TSLint</code>是TypeScript的Lint文件。</p>
<ol>
<li>先安装： <code>tnpm install --save-dev tslint</code>    </li>
<li>再安装插件：<code>TSLint</code>   </li>
<li>最后在项目下新建一个tslint.json文件，这是规则文件，可以参考<a href="https://github.com/palantir/tslint/blob/master/tslint.json" target="_blank" rel="external">https://github.com/palantir/tslint/blob/master/tslint.json</a> 这里的例子。  </li>
<li>此时编辑器已经对你的ts或者tsx文件开始进行检查了。  </li>
</ol>
<h3 id="三、使用TSX一些额外注意的地方："><a href="#三、使用TSX一些额外注意的地方：" class="headerlink" title="三、使用TSX一些额外注意的地方："></a>三、使用TSX一些额外注意的地方：</h3><h4 id="1-类型断言"><a href="#1-类型断言" class="headerlink" title="1. 类型断言"></a>1. 类型断言</h4><p>使用纯TypeScript，可以对类型进行断言:</p>
<pre><code>let foo: any = &apos;just a string&apos;;
let bar: number = (&lt;string&gt;foo).length;
</code></pre><p>此时会告诉编译器，请把any类型的foo当作string类型看待(不论是不是string)，但是在tsx文件中，只能使用<code>as</code>进行断言：</p>
<pre><code>let foo: any = &apos;just a string&apos;;
let bar: number = (foo as string).length;
</code></pre><p>这个问题主要还是因为对尖括号的识别引起的。所有遇到类型断言的地方，都应该使用<code>as</code>替代左右尖括号。</p>
<p>PS: 泛型并不需要，因为语法解析的时候可以正确的识别尖括号里面的是泛型还是DOM元素。</p>
<h4 id="2-React-Class写法"><a href="#2-React-Class写法" class="headerlink" title="2. React Class写法"></a>2. React Class写法</h4><p>所有React组件类都需要继承这一个类：</p>
<pre><code>React.Component&lt;IAppProps, IAppState&gt;
</code></pre><p>其中必须使用泛型<code>IAppProps</code>和<code>IAppState</code>,分别指定了<code>props</code>的类型和<code>state</code>的类型，应该可以使用interface的方式指定约束，这样编辑器在访问<code>props</code>,<code>state</code>属性以及<code>setState</code>,<code>nextProps</code>等的时候都能进行校验(你也可以指定any放弃校验，或者根本不需要使用时)，这样就把propType的校验提前到编译阶段了。</p>
<p>render方法是这么定义的：</p>
<pre><code>public render(): JSX.Element { 

     /** Render Code **/

}
</code></pre><p>其中返回类型是可以不用写的，因为父类已经定义好了返回类型。</p>
<p>参考Antd的写法，一般来说这些类型定义都放在同一个文件中。        </p>
<h4 id="3-结合Redux或者其他第三方库"><a href="#3-结合Redux或者其他第三方库" class="headerlink" title="3. 结合Redux或者其他第三方库"></a>3. 结合Redux或者其他第三方库</h4><p>现在比较流行的库都自带了<code>xxx.d.ts</code>文件来定义一些元数据，如果没有，可以在npm仓库搜索<code>@types/xxx</code>下载相应的元数据文件(比如一开始需要安装的<code>@types/react</code>等等)。</p>
<p>redux自带了index.d.ts文件，提供了常见一些redux方法的实现，比如<code>applyMiddleware</code>等等，至于写action和reducer，则完全遵从TypeScript的规范即可。</p>
<h3 id="四、其他补充"><a href="#四、其他补充" class="headerlink" title="四、其他补充"></a>四、其他补充</h3><p>总体来说感觉TypeScript能规范不少代码规则，提高开发和Review的效率，更多的东西，正在不断的探索和研究中……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Webpack项目添加TypeScript支持&quot;&gt;&lt;a href=&quot;#一、Webpack项目添加TypeScript支持&quot; class=&quot;headerlink&quot; title=&quot;一、Webpack项目添加TypeScript支持&quot;&gt;&lt;/a&gt;一、Webpack项目
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>丑化你的JS代码</title>
    <link href="https://mongoosesong.github.io/2017/06/13/uglifyjs/"/>
    <id>https://mongoosesong.github.io/2017/06/13/uglifyjs/</id>
    <published>2017-06-13T11:57:59.000Z</published>
    <updated>2017-06-13T11:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>UglifyJS，即压缩JavaScript代码。作为前端开发，我们通常都会在发布代码前，对HTML、CSS、JavaScript代码进行一次压缩，精简代码大小，并且防止源代码泄露。在Webpack出现后，我们可以直接用webpack.optimize.UglifyJsPlugin来进行最终的代码压缩，这篇文章会简单分析一下UglifyJS的工作原理，并说明UglifyJS到底会做什么事情。</p>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><p>任何一个编译器不能避免的操作首先是对代码进行词法分析，通过逐个扫描代码字符识别到关键词、注释、操作符、变量、字符串和数字等等，一个直观的词法分析作用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var target = 985;</div><div class="line"></div><div class="line">// 词法分析后的结果</div><div class="line">[</div><div class="line">  &quot;var&quot; : &quot;keyword&quot;,</div><div class="line">  &quot;target&quot; : &quot;identifier&quot;,</div><div class="line">  &quot;=&quot;   : &quot;assignment&quot;,</div><div class="line">  &quot;985&quot;  : &quot;integer&quot;,</div><div class="line">  &quot;;&quot;   : &quot;eos&quot; (end of statement)</div><div class="line">]</div></pre></td></tr></table></figure>
<h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2. 语法分析"></a>2. 语法分析</h3><p>词法分析之后就是语法分析，具体来说，就是来识别语句具体是什么意义，如果词法定义了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">主语: &quot;猫&quot; | &quot;狗&quot;;</div><div class="line">谓语: &quot;吃&quot; | &quot;喝&quot;;</div><div class="line">宾语: &quot;食物&quot; | &quot;水&quot;</div></pre></td></tr></table></figure>
<p>如果我定义一个语法是”主语 谓语 宾语”，那么“猫 喝 水”就是合法的语句，而“猫 吃 喝”虽然能通过词法检查，但是因为找不到合适的语法规则，所以会报出语法解析错误。<br>通常，我们会通过构建AST(Abstract Syntax Tree，抽象语法树)来分析语法，我们把每一个词法识别出来的字符作为树上的节点元素，这是整个编译器里面最重要的环节。<br>接上面词法分析的结果, 语法分析的结果示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  operation: &quot;=&quot;,</div><div class="line">  left: &#123;</div><div class="line">    keyword: &quot;var&quot;,</div><div class="line">    right: &quot;target&quot;</div><div class="line">  &#125;</div><div class="line">  right: &quot;985&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的JS词法和语法分析工具有<a href="https://github.com/zaach/jison" target="_blank" rel="external">Jison</a>(CoffeeScript), 还有<a href="https://github.com/mishoo/cl-uglify-js" target="_blank" rel="external">Cl-Uglify-Js</a>(UglifyJS)等。</p>
<h3 id="3-UglifyJS的规则"><a href="#3-UglifyJS的规则" class="headerlink" title="3.UglifyJS的规则"></a>3.UglifyJS的规则</h3><p>本文的重点是这一部分，会列举在识别到什么样的语法时，进行什么样的精简操作。<br>不过要注意的是每个Uglify的实现都是不一样的，大家都会遵循一些基础的原则，某些情况下可以更智能的转化：</p>
<h4 id="1-变量名称的混淆原则"><a href="#1-变量名称的混淆原则" class="headerlink" title="(1) 变量名称的混淆原则"></a>(1) 变量名称的混淆原则</h4><p>规则： 只有作用域上面的变量名称可以被混淆，全局变量名称不可被混淆。<br>解释： 全局变量相关的有可能被别的文件所引用，故不能混淆。</p>
<p>规则： 函数的参数名称可以混淆。<br>解释： 函数参数本质上就是出于局部作用域上的变量，故可以混淆。</p>
<p>规则： 使用eval生成的代码不能被混淆。<br>解释： 不用解释……</p>
<p>规则： 使用了with定义的作用域内部的变量不会被混淆。<br>解释： 因为使用with定义的作用域内部，无法在编译时期确定到底访问的是哪一个变量，故不能混淆。</p>
<h4 id="2-变量名混淆的优先级"><a href="#2-变量名混淆的优先级" class="headerlink" title="(2) 变量名混淆的优先级"></a>(2) 变量名混淆的优先级</h4><p>规则： 字母优先级”etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV”。<br>解释： 据说这样可以使GZip生成的代码体积更小。</p>
<p>规则： 当前作用域不同变量混淆后的变量名不能重复，同时混淆后的名字不能是关键字。<br>解释： 所有的混淆都是基于作用域来定了，一个作用域下混淆过的变量名要按照优先级顺序拼装。</p>
<h4 id="3-表达式的压缩"><a href="#3-表达式的压缩" class="headerlink" title="(3) 表达式的压缩"></a>(3) 表达式的压缩</h4><p>规则： 如果表达式的结果可以提前计算，并且生成体积会小于原来表达式，则可以执行提前计算。<br>举例： <code>var expr1 = 3 + 5</code> 会被压缩成 <code>var expr1 = 8</code><br>举例： <code>var expr1 = 1 / 3</code> 不会被压缩成 <code>var expr1 = 0.333333...</code>， 因为计算过后的结果长度会明显大于前面的表达式。</p>
<p>规则： true会转化成!0, false会转化成!1<br>解释： 很显然按照此种方式可以缩短2-3个字符，并且不影响后面的比较</p>
<p>规则： 利用短路特性预计算 &amp;&amp; 和 || 表达式的结果<br>举例： true &amp;&amp; say() 会被压缩成 A()</p>
<p>规则： 尽量使用二元操作符替换赋值表达式<br>举例： var a = a + b 会被压缩成 var a += b;</p>
<h4 id="4-函数的压缩"><a href="#4-函数的压缩" class="headerlink" title="(4) 函数的压缩"></a>(4) 函数的压缩</h4><p>规则： 去除没有使用的函数参数<br>举例： <code>function abc(a, b, c){ console.log(a, b) }</code> 会被压缩为 <code>function(a, b){console.log(a, b)}</code></p>
<p>规则： 去除根本不会执行的while循环：while(false){}<br>解释： 也不排除有人会写这种代码…</p>
<p>规则： while(true)变成for(;;)<br>解释： 少写4个字符…</p>
<p>规则： 多个变量定义可以合并成一句话<br>举例： <code>function A(){ var a; var b; var c;}</code> 会被压缩为 <code>function A(){var a,b,c;}</code><br>解释： 很多JS编译器都会做这种事情，因为JS本来就是有变量定义提升的功能。</p>
<p>规则： 如果if/else其中一个块为空，另一个块只有一条语句，则可以化成||或者&amp;&amp;的表达式。<br>举例： <code>if (A){ B(); }</code> 会被压缩成 <code>A&amp;&amp;B();</code></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>其实之前自己刚接触前端时，很好奇Js代码是怎么压缩的。现在想想其实做的事情也不麻烦，主要是定义足够的语法规则，并且需要使用一些额外的变量来存放一些使用过的变量名，我们会使用BeautifyJS来格式化自己的代码，UglifyJS来压缩自己的代码，可能大家会谈很多原则用来如何优雅的写代码，我这篇文章也算从机器的角度来解释压缩的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UglifyJS，即压缩JavaScript代码。作为前端开发，我们通常都会在发布代码前，对HTML、CSS、JavaScript代码进行一次压缩，精简代码大小，并且防止源代码泄露。在Webpack出现后，我们可以直接用webpack.optimize.UglifyJsPl
    
    </summary>
    
    
      <category term="前端" scheme="https://mongoosesong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开发工具" scheme="https://mongoosesong.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="https://mongoosesong.github.io/2017/06/13/react-lifecycle/"/>
    <id>https://mongoosesong.github.io/2017/06/13/react-lifecycle/</id>
    <published>2017-06-13T11:43:55.000Z</published>
    <updated>2017-06-13T11:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章简单总结我使用React以来对其生命周期的一些理解。</p>
<h2 id="一、React原理"><a href="#一、React原理" class="headerlink" title="一、React原理"></a>一、React原理</h2><p>在介绍React生命周期之前，有必要先介绍一下React框架的基本工作原理，这样再解释起来会更快一点。</p>
<p>正如很多文章所说的，React并不是一个大一统的MVC框架，它只是一个View层。</p>
<p>React的核心是组件 + 虚拟DOM，通过组件 <strong>render</strong> 方法返回的生成虚拟DOM代码的逻辑，和上次render返回的结果作Diff比较，并计算出到底应该渲染哪一个实际DOM，此乃React框架的核心概念和算法。</p>
<p>React一个重要特点是高度组件化，一个页面上所有展示的内容都可以化成各式各样的组件，每个组件都负责内部的渲染逻辑。彼此之间，在数据流不相关的情况下，互不干扰。通常来说，React的组件都是可重用可维护的。</p>
<p>React另一个特点是单向的数据流，父组件和子组件之间可以通过state和props传递信息，而子组件和子组件之间只能通过父组件通信，在某种程度上会简化代码逻辑，但是也可能会导致编程的复杂。</p>
<p>某种意义上来说，React和直接操作DOM的库如jQuery是冲突的，不过React仍然会遵循使用者的意愿，即当虚拟节点生成的DOM被操作过后，以后都不会再去管理这个DOM。不过这种事还是尽量少做。</p>
<p>React所有组件都遵循一套统一的规范，如果说render方法是每一个组件的灵魂，那么作为钩子的那些生命周期函数可以作为躯体来使组件成为一个完整的组件。下文会综合整理一下相关的内容。</p>
<h2 id="二、组件初始化"><a href="#二、组件初始化" class="headerlink" title="二、组件初始化"></a>二、组件初始化</h2><p>一个通常的React组件(继承了React.Component)，在<strong>初始化</strong>时会<strong>按顺序</strong>经历如下阶段：  </p>
<ol>
<li><code>constructor(initProps)</code><br>这个方法只会调用一次，组件刚刚生成的时候调用，这里可以通过 this.state = { xxx } 来初始化state。  </li>
<li><code>componentWillMount()</code><br>这个方法只调用一次，在执行render方法前执行，在这个方法里可以通过this.setState()方法设置一个初始state,不过用处不大，似乎这样的写法比较少。  </li>
<li><code>render()</code><br>在执行完willMount后会通过执行render方法生成虚拟DOM并进一步生成实际DOM挂载到实际的HTML文档上。  </li>
<li><code>componentDidMount()</code><br>这个方法只调用一次，在执行render方法后执行，此时真实DOM了已经存在了，此方法里面调用this.setState()将会把新state修改提交到render队列中(关于render的机制下文会说)通常来说，异步Fetch初始数据等初始化操作都会放在此钩子函数中调用。</li>
</ol>
<p>值得一提的是，通过React.createClass()方法还有可以有下面两个方法：<br><code>getDefaultProps()</code><br><code>getInitState()</code><br>两个方法都return一个对象作为初始的Props或者State，在ES6写法中这两个方法是不被支持的，初始化state，可以在constructor中指定。指定默认的props，可以在组件代码中按如下方式书写：  </p>
<pre><code>static defaultProps = { 
    //default Props
};</code></pre>

<h2 id="三、组件更新"><a href="#三、组件更新" class="headerlink" title="三、组件更新"></a>三、组件更新</h2><p>触发组件更新的方法主要有两种：一是组件自身state变化，二是父组件传递进来的props变化。<br>props和自身state变化区别是，多了这么一个函数:<br><code>componentWillReceiveProps(nextProps)</code><br>这个函数内，this.props代表当前的props状态，nextProps是接受到props状态，这也是React组件唯一可以感知到props变化的函数。<br>通常这里会有一些和父组件相关的，比如某个props改变需要导致重新Fetch数据，这里去做操作的时候一定需要注意避免循环改变导致的无限渲染，这里可能就涉及到比较props几个属性来决定是否要setState()或者通过方法修改父组件props(在Redux中需要额外注意)。<br><code>shouldComponentUpdate(nextProps, nextState)</code><br>这个用来判断是否需要执行下面列出的方法。也许是非常重要的函数，了解React渲染的机制的同学应该都了解，React的render方法可能会被频繁的调用，计算整个内存DOM树和Diff也是需要花费时间的，特别是根组件下面的render，设计的不好会导致前端运行效率大幅度降低。虽然通常情况下不需要手动实现这个方法 (默认返回<code>true</code>) 。<br>React提供了PureComponent，它提供了默认的一种非常简单的shouldComponentUpdate实现，仅仅去把Props和State作一层浅比较，通过迭代比较对象的keys并在对象的key值不严格相等时返回false。很多时候，此功能并不能完全的满足我们的需求，而如果对对象进行深层次的递归遍历比较，成本又会很大，甚至会导致性能的进一步下降，在state或者props非常庞大的时候，可以考虑使用<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js</a>。<br><code>componentWillUpdate(nextProps, nextState)</code><br>这个方法会在组件触发render前执行，这个方法里面不要做setState的操作，大部分时候这个函数是可选的，按需要实现。<br><code>render</code><br>所以这一步终于到了render。<br><code>componentDidUpdate(preProps, preState)</code><br>这个函数目前发现有两点用处，一是作为子组件render完的标志通知父组件，不过一定要小心循环调用。还有一点是理解为子组件更新状态后的componentDidMount方法，此时新生产的DOM已经存在了，可以做一些额外的操作(比如scrollIntoView之类的…)</p>
<h2 id="四、组件销毁"><a href="#四、组件销毁" class="headerlink" title="四、组件销毁"></a>四、组件销毁</h2><p>组件销毁可能有两种情况，第一种是其自身在父组件被移除了，还有一种是设置了key属性，父组件在render的时候，发现这个组件key值变了，那么原来的会被销毁掉，生成一个新的。<br><code>componentWillUnmount()</code><br>这个函数会在组件被移除前调用，此时DOM还是存在的，一般是在这里做一些清除扫尾的工作，比如清除掉定时器。</p>
<h2 id="五、关于setState和render"><a href="#五、关于setState和render" class="headerlink" title="五、关于setState和render"></a>五、关于setState和render</h2><p>和React打交道，永远不可能摆脱这两个方法，下面奉上我的理解。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>调用setState是有原则的，不能在render中调用，在<code>componentWillUpdate</code>和<code>componentDidUpdate</code>中调用需要注意时机以避免死循环。<br>React有一个state队列来管理需要改变的state，每次通过setState,实质上是把新的state扔进了state队列里面，每隔一段时间，React检查state队列里面的内容，并将其作合并操作，合并的结果会触发组件更新的一系列方法(即使新state和上一个state一样)。<br>所以虽然不建议在一个组件里面同步的调用多次setState，但是因为有了这种机制，也不会导致多次render的情况。<br>setState还有第二个参数，是一个callback，用于在此次setState导致的<code>componentDidUpdate</code>之后再次调用。不过值得一提的是如果<code>shouldComponentUpdate</code>返回了false，这个callback仍然会被调用。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>通过调用render返回的虚拟DOM或许是React最耗时的操作，很多时候，我们应该简化render方法或者减少render的不必要调用，在非常庞大的项目下，实现<code>shouldComponentUpdate</code>应该是必不可少的。另外，对于那种异步搜索框，可以使用lodash的<code>throttle</code>方法或者<code>debounce</code>方法减少请求和render次数。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>React的入门门槛很低，但是去做大项目的架构设计，还是很需要认真思考的。<br>复杂可能包括三个方面：<br>一个是数据流设计，这是核心，也是灵魂。<br>一个是页面上View组件的架构，组件之间的彼此关系。<br>一个是View组件的实现，现在集团有AntD和Fusion提供了很多组件的实现，可以在上面包装一层成为自己的业务组件。<br>使用React开发出一个健壮、高性能的复杂页面，还是相当具有挑战的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章简单总结我使用React以来对其生命周期的一些理解。&lt;/p&gt;
&lt;h2 id=&quot;一、React原理&quot;&gt;&lt;a href=&quot;#一、React原理&quot; class=&quot;headerlink&quot; title=&quot;一、React原理&quot;&gt;&lt;/a&gt;一、React原理&lt;/h2&gt;&lt;p&gt;在介绍R
    
    </summary>
    
    
      <category term="React" scheme="https://mongoosesong.github.io/tags/React/"/>
    
      <category term="前端" scheme="https://mongoosesong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
