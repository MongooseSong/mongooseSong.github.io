<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> React生命周期 | The Song from A Mongoose</title><meta name="description" content="React生命周期 - mongoose"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/scss/casual.css"><link rel="stylesheet" href="/css/icon.css"><link rel="search" type="application/opensearchdescription+xml" href="https://mongoosesong.github.io/atom.xml" title="The Song from A Mongoose"></head><body><div class="header"><header class="site-header"><div class="site-nav"><span class="button-toggle"></span><div class="container"><div class="nav-item"><a href="/" target="_self" data-text="home">主页</a></div><div class="nav-item"><a href="/archives" target="_self" data-text="archive">归档</a></div><div class="nav-item"><a href="/about" target="_self" data-text="about">关于</a></div><div class="nav-item"><a href="/atom.xml" target="_self" data-text="rss">订阅</a></div></div><form id="search-form" class="nav-item"><input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" autocomplete="off" autocorrect="off" class="search form-control"><span onclick="resetSearch()" class="fa fa-times"> </span></form><div id="local-search-result"></div><p class="no-result">No results found</p></div></header></div><div class="main"><div class="container"><div class="content"><div class="post"><article class="post-block"><h1 class="post-title">React生命周期</h1><span class="post-date">2017年6月13日</span><span class="post-tag"><a href="/tags/前端/">前端</a><a href="/tags/React/">React</a></span><span class="post-review">阅读次数 : <span data-hk-page="current">-</span></span><div class="post-content"><p>这篇文章简单总结我使用React以来对其生命周期的一些理解。</p>
<h2 id="一、React原理"><a href="#一、React原理" class="headerlink" title="一、React原理"></a>一、React原理</h2><p>在介绍React生命周期之前，有必要先介绍一下React框架的基本工作原理，这样再解释起来会更快一点。</p>
<p>正如很多文章所说的，React并不是一个大一统的MVC框架，它只是一个View层。</p>
<p>React的核心是组件 + 虚拟DOM，通过组件 <strong>render</strong> 方法返回的生成虚拟DOM代码的逻辑，和上次render返回的结果作Diff比较，并计算出到底应该渲染哪一个实际DOM，此乃React框架的核心概念和算法。</p>
<p>React一个重要特点是高度组件化，一个页面上所有展示的内容都可以化成各式各样的组件，每个组件都负责内部的渲染逻辑。彼此之间，在数据流不相关的情况下，互不干扰。通常来说，React的组件都是可重用可维护的。</p>
<p>React另一个特点是单向的数据流，父组件和子组件之间可以通过state和props传递信息，而子组件和子组件之间只能通过父组件通信，在某种程度上会简化代码逻辑，但是也可能会导致编程的复杂。</p>
<p>某种意义上来说，React和直接操作DOM的库如jQuery是冲突的，不过React仍然会遵循使用者的意愿，即当虚拟节点生成的DOM被操作过后，以后都不会再去管理这个DOM。不过这种事还是尽量少做。</p>
<p>React所有组件都遵循一套统一的规范，如果说render方法是每一个组件的灵魂，那么作为钩子的那些生命周期函数可以作为躯体来使组件成为一个完整的组件。下文会综合整理一下相关的内容。</p>
<h2 id="二、组件初始化"><a href="#二、组件初始化" class="headerlink" title="二、组件初始化"></a>二、组件初始化</h2><p>一个通常的React组件(继承了React.Component)，在<strong>初始化</strong>时会<strong>按顺序</strong>经历如下阶段：  </p>
<ol>
<li><code>constructor(initProps)</code><br>这个方法只会调用一次，组件刚刚生成的时候调用，这里可以通过 this.state = { xxx } 来初始化state。  </li>
<li><code>componentWillMount()</code><br>这个方法只调用一次，在执行render方法前执行，在这个方法里可以通过this.setState()方法设置一个初始state,不过用处不大，似乎这样的写法比较少。  </li>
<li><code>render()</code><br>在执行完willMount后会通过执行render方法生成虚拟DOM并进一步生成实际DOM挂载到实际的HTML文档上。  </li>
<li><code>componentDidMount()</code><br>这个方法只调用一次，在执行render方法后执行，此时真实DOM了已经存在了，此方法里面调用this.setState()将会把新state修改提交到render队列中(关于render的机制下文会说)通常来说，异步Fetch初始数据等初始化操作都会放在此钩子函数中调用。</li>
</ol>
<p>值得一提的是，通过React.createClass()方法还有可以有下面两个方法：<br><code>getDefaultProps()</code><br><code>getInitState()</code><br>两个方法都return一个对象作为初始的Props或者State，在ES6写法中这两个方法是不被支持的，初始化state，可以在constructor中指定。指定默认的props，可以在组件代码中按如下方式书写：  </p>
<pre><code>static defaultProps = { 
    //default Props
};</code></pre>

<h2 id="三、组件更新"><a href="#三、组件更新" class="headerlink" title="三、组件更新"></a>三、组件更新</h2><p>触发组件更新的方法主要有两种：一是组件自身state变化，二是父组件传递进来的props变化。<br>props和自身state变化区别是，多了这么一个函数:<br><code>componentWillReceiveProps(nextProps)</code><br>这个函数内，this.props代表当前的props状态，nextProps是接受到props状态，这也是React组件唯一可以感知到props变化的函数。<br>通常这里会有一些和父组件相关的，比如某个props改变需要导致重新Fetch数据，这里去做操作的时候一定需要注意避免循环改变导致的无限渲染，这里可能就涉及到比较props几个属性来决定是否要setState()或者通过方法修改父组件props(在Redux中需要额外注意)。<br><code>shouldComponentUpdate(nextProps, nextState)</code><br>这个用来判断是否需要执行下面列出的方法。也许是非常重要的函数，了解React渲染的机制的同学应该都了解，React的render方法可能会被频繁的调用，计算整个内存DOM树和Diff也是需要花费时间的，特别是根组件下面的render，设计的不好会导致前端运行效率大幅度降低。虽然通常情况下不需要手动实现这个方法 (默认返回<code>true</code>) 。<br>React提供了PureComponent，它提供了默认的一种非常简单的shouldComponentUpdate实现，仅仅去把Props和State作一层浅比较，通过迭代比较对象的keys并在对象的key值不严格相等时返回false。很多时候，此功能并不能完全的满足我们的需求，而如果对对象进行深层次的递归遍历比较，成本又会很大，甚至会导致性能的进一步下降，在state或者props非常庞大的时候，可以考虑使用<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js</a>。<br><code>componentWillUpdate(nextProps, nextState)</code><br>这个方法会在组件触发render前执行，这个方法里面不要做setState的操作，大部分时候这个函数是可选的，按需要实现。<br><code>render</code><br>所以这一步终于到了render。<br><code>componentDidUpdate(preProps, preState)</code><br>这个函数目前发现有两点用处，一是作为子组件render完的标志通知父组件，不过一定要小心循环调用。还有一点是理解为子组件更新状态后的componentDidMount方法，此时新生产的DOM已经存在了，可以做一些额外的操作(比如scrollIntoView之类的…)</p>
<h2 id="四、组件销毁"><a href="#四、组件销毁" class="headerlink" title="四、组件销毁"></a>四、组件销毁</h2><p>组件销毁可能有两种情况，第一种是其自身在父组件被移除了，还有一种是设置了key属性，父组件在render的时候，发现这个组件key值变了，那么原来的会被销毁掉，生成一个新的。<br><code>componentWillUnmount()</code><br>这个函数会在组件被移除前调用，此时DOM还是存在的，一般是在这里做一些清除扫尾的工作，比如清除掉定时器。</p>
<h2 id="五、关于setState和render"><a href="#五、关于setState和render" class="headerlink" title="五、关于setState和render"></a>五、关于setState和render</h2><p>和React打交道，永远不可能摆脱这两个方法，下面奉上我的理解。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>调用setState是有原则的，不能在render中调用，在<code>componentWillUpdate</code>和<code>componentDidUpdate</code>中调用需要注意时机以避免死循环。<br>React有一个state队列来管理需要改变的state，每次通过setState,实质上是把新的state扔进了state队列里面，每隔一段时间，React检查state队列里面的内容，并将其作合并操作，合并的结果会触发组件更新的一系列方法(即使新state和上一个state一样)。<br>所以虽然不建议在一个组件里面同步的调用多次setState，但是因为有了这种机制，也不会导致多次render的情况。<br>setState还有第二个参数，是一个callback，用于在此次setState导致的<code>componentDidUpdate</code>之后再次调用。不过值得一提的是如果<code>shouldComponentUpdate</code>返回了false，这个callback仍然会被调用。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>通过调用render返回的虚拟DOM或许是React最耗时的操作，很多时候，我们应该简化render方法或者减少render的不必要调用，在非常庞大的项目下，实现<code>shouldComponentUpdate</code>应该是必不可少的。另外，对于那种异步搜索框，可以使用lodash的<code>throttle</code>方法或者<code>debounce</code>方法减少请求和render次数。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>React的入门门槛很低，但是去做大项目的架构设计，还是很需要认真思考的。<br>复杂可能包括三个方面：<br>一个是数据流设计，这是核心，也是灵魂。<br>一个是页面上View组件的架构，组件之间的彼此关系。<br>一个是View组件的实现，现在集团有AntD和Fusion提供了很多组件的实现，可以在上面包装一层成为自己的业务组件。<br>使用React开发出一个健壮、高性能的复杂页面，还是相当具有挑战的。</p>
</div></article></div><div class="post-paginator"><div class="post-links"><div class="post-prev"><a href="/2017/06/13/uglifyjs/" class="prev">上一篇<span>丑化你的JS代码</span></a></div></div></div><div id="uyan_frame"></div></div><div class="sidebar"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/littlewin-wang" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="http://twitter.com/littlewin_wang" target="_blank" class="link-twitter"><i class="icon icon-twitter"></i></a></li><li class="social-link"><a href="http://weibo.com/fredinweibo" target="_blank" class="link-weibo"><i class="icon icon-weibo"></i></a></li><li class="social-link"><a href="mailto:littlewin.wang@gmail.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div><div class="recent-posts widget"><h3 class="widget-title"> 近期文章</h3><div class="widget-content"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/react-typescript/">使用TypeScript集成React</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/uglifyjs/">丑化你的JS代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/react-lifecycle/">React生命周期</a></li></ul></div></div><div class="recent-comment widget"><h3 class="widget-title"> 近期评论</h3><div class="widget-content"><div id="uyan_newcmt_unit"></div></div></div><div class="tag-lists widget"><h3 class="widget-title"> 标签</h3><div class="widget-content"><a class="tag-link" href="/tags/React/">React</a> <a class="tag-link" href="/tags/前端/">前端</a> <a class="tag-link" href="/tags/开发工具/">开发工具</a></div></div><div class="archive-lists widget"><h3 class="widget-title"> 归档</h3><div class="widget-content"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li></ul></div></div></div></div></div><footer><div class="copyright"><div class="container"><div class="col-6"><div class="site-info">© 2016 - 2017 <span class="icon icon-heart"></span> <a href="https://mongoosesong.github.io">mongoose</a><span class="sep">/</span><a href="https://hexo.io/" target="_blank">Powered by Hexo</a><span class="sep">/</span><a href="https://github.com/littlewin-wang/hexo-theme-casual" target="_blank">Theme by casual</a></div></div><div class="col-6"><div class="site-contact"><div class="social-links"><ul><li class="social-link"><a href="http://github.com/littlewin-wang" target="_blank" class="link-github"><i class="icon icon-github"></i></a></li><li class="social-link"><a href="http://twitter.com/littlewin_wang" target="_blank" class="link-twitter"><i class="icon icon-twitter"></i></a></li><li class="social-link"><a href="http://weibo.com/fredinweibo" target="_blank" class="link-weibo"><i class="icon icon-weibo"></i></a></li><li class="social-link"><a href="mailto:littlewin.wang@gmail.com" target="_self" class="link-mail"><i class="icon icon-mail"></i></a></li></ul></div></div></div></div></div></footer><a class="scroll-up"><span class="icon icon-up"></span></a><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script><script src="/js/posfixed.js"></script><script src="/js/utils.js"></script><script src="/js/search.js"></script><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2128137"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-92791318-1",'auto');ga('send','pageview');</script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script></body></html>