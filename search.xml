<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[关于Immutable的这些那些]]></title>
      <url>/2017/07/13/immutable/</url>
      <content type="html"><![CDATA[<h3 id="1-何为Immutable"><a href="#1-何为Immutable" class="headerlink" title="1. 何为Immutable"></a>1. 何为Immutable</h3><p>“Immutable”的中文意思是”不可变”，与之相呼应的单词为”mutable”，意为”可变”。在JavaScript的世界里，大部分类型都是可变类型。举个例子，如果一个对象A拥有属性a，那么在把A赋值给新对象B之后，修改B下面a的属性，也会导致A的a属性被修改。本质上来说，这是引用类型的特质，在方便我们开发的同时，往往也会带来意料之外的事情。</p>
<p>比如，使用Redux管理数据的时候，为了保证组件能够正确的触发渲染时机，通常遵守约定在Reducer中返回一个新的对象，存在的一个问题是即使里边的数据没变，也会导致组件认为接收到了新的State导致被渲染，另外一个问题是在做shouldComponentUpdate的时候，需要比较比较复杂的数据元素时，性能消耗太大。</p>
<p>FaceBook的工程师花费3年打造了最有名的<a href="https://github.com/facebook/immutable-js" target="_blank" rel="external">前端ImmutableJS框架</a>，这篇文章会简单探讨一下这个框架以及和React、Redux以及Typescript集成的情况。</p>
<h3 id="2-ImmutableJS"><a href="#2-ImmutableJS" class="headerlink" title="2. ImmutableJS"></a>2. ImmutableJS</h3><p><a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">官方网站</a>上给出了足够详尽的Demo和Api Doc，这里不再去花费时间详述，只是简单的描述一下特性：</p>
<ul>
<li>所有Immutable类型的对象不能被直接赋值，必须通过类似set、setIn、updateIn等的方式修改其中的属性值。</li>
<li>一旦被赋值之后，如果这个Immutable对象属性值确实发生改变，会返回一个新对象，否则仍然是原来的对象。</li>
<li>因为上一点特性，所以比较两个Immutable对象内容是否一致时，直接使用 === 就可以了。</li>
</ul>
<p>把一个普通对象转化成Immutable对象有很多种方法，最常见的是<code>fromJS(plainObject)</code>，而且Immutable自己实现了一套数据结构用来实现不可变的功能，完全没有基于ES5的defineProperty，理论上应该可以支持大部分浏览器。</p>
<p>常见的API是通过set，update等方法修改数据，非直接属性可以通过updateIn([‘a’, ‘b’], callback)等方式修改，这些方法都会返回对象。另外一些常见搜索，遍历等也可以通过查看API文档获取。</p>
<h3 id="3-React和Immutable"><a href="#3-React和Immutable" class="headerlink" title="3. React和Immutable"></a>3. React和Immutable</h3><p>React官方是<a href="https://facebook.github.io/react/docs/optimizing-performance.html#using-immutable-data-structures" target="_blank" rel="external">建议使用Immutable的方式来做State管理的优化</a>，其本身也有一个简单的<a href="https://facebook.github.io/react/docs/update.html" target="_blank" rel="external">Immutable Helper</a>实现。需要注意的是不能让一个State直接成为一个Immutable对象，而是让一个Immutable对象作为State的一个属性。</p>
<p>举个例子，你不能让this.state === 一个Immutable对象，而是要让this.state.key === 一个Immutable对象。</p>
<p>结合TypeScript的写法 可以参见我的一份<a href="http://gitlab.alibaba-inc.com/zhenxi.gzx/TypedMunin/blob/master/src/pages/immutable_state/ImmutableState.tsx" target="_blank" rel="external">ImmutableState Demo</a>。</p>
<p>不过大部分情况下，除非State结构非常复杂，一般不需要引入。即使引入，也主要是为了加快对象相等的判断。</p>
<h3 id="4-Redux和Immutable"><a href="#4-Redux和Immutable" class="headerlink" title="4. Redux和Immutable"></a>4. Redux和Immutable</h3><p>同样可以参见我的<a href="http://gitlab.alibaba-inc.com/zhenxi.gzx/TypedMunin/tree/master/src/pages/immutable_redux" target="_blank" rel="external">示例项目</a>，注意点有两个地方，一个是在Reducer那层定义State为一个Immutable对象，二是在mapStateToProps的时候，需要把这个对象转化成一个PlainObject，在View层面，理论上完全不需要感知到Immutable的存在。</p>
<p>一个比较明显的好处是，如果update后数据和之前的State保持一致，因为Immutable会返回同一个对象，所以不会导致页面被render一次。（比如页面起了一个轮询，如果轮询结果一致，甚至都不需要写shouldUpdate）</p>
<p>事实上，本身适合使用Redux的已经就是一个大项目了，再加上Immutable对象，结合TypeScript的语法，个人觉得适合一张相当复杂的页面（比如工作流或者文本编辑器等等），否则会给开发进度带来一些负面影响，这也是我在调研Immutable之后，基于新项目的复杂度，决定暂时不使用该框架的原因。</p>
<h3 id="5-总述"><a href="#5-总述" class="headerlink" title="5. 总述"></a>5. 总述</h3><p>Immutable的出现很好的改变了我们使用JavaScript的认知，Immutable的好处是非常多的，他亦可以保证你的函数实参被意外的修改，只是因为不能按照通常方式赋值和使用，带来了许多不便。目前看来，这是对付大型项目一个相当理想的办法。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Git子模块实战]]></title>
      <url>/2017/06/20/gitsubmodule/</url>
      <content type="html"><![CDATA[<h3 id="一、什么是Git-子模块"><a href="#一、什么是Git-子模块" class="headerlink" title="一、什么是Git 子模块"></a>一、什么是Git 子模块</h3><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个.</p>
<p>我就遇到了这个问题，外部的调度2.0系统已经开发完成了，内部版需要大量复用外部版的代码，苦思冥想很多天，终于发现原生的Git子模块功能就可以帮忙解决这个问题。下面分享一下我的经验。</p>
<h3 id="二、子模块的创建和拉取"><a href="#二、子模块的创建和拉取" class="headerlink" title="二、子模块的创建和拉取"></a>二、子模块的创建和拉取</h3><h4 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h4><p>当我有一个Git项目GA，现在想创建一个Git项目GB，GA需要以GB的子模块形式存在，那么在GB项目中，需要通过以下的命令创建GA子模块。</p>
<pre><code>## GB目录下
git submodule add ${GA项目地址}
</code></pre><p>默认情况下，子模块会在当前目录下面，将子项目放到一个与仓库同名的目录中。</p>
<p>运行<code>git status</code>，可以发现根目录下多了一个<code>.gitmodules</code>文件，这里面会存放跟模块相关的信息。</p>
<p>此时可以运行<code>git add</code>和<code>git commit</code>以及<code>git push</code>等功能，就可以推送含有子模块的代码上去。</p>
<h4 id="2-克隆"><a href="#2-克隆" class="headerlink" title="2. 克隆"></a>2. 克隆</h4><p>当需要克隆一个含有GA子项目的GB项目，方法如下：</p>
<pre><code>git clone ${GB项目地址}
</code></pre><p>这一步只会产生目录，并不会拉取子项目，拉取子项目的代码，需要按照以下方式执行：</p>
<pre><code>### 初始化子项目配置
git submodule init
### 拉取子项目代码
git submodule update
</code></pre><p>如果觉得以上命令太复杂了，那么可以一行命令搞定：</p>
<pre><code>git clone --recursive ${GB项目地址}             
</code></pre><h3 id="三、子模块的修改，提交和推送"><a href="#三、子模块的修改，提交和推送" class="headerlink" title="三、子模块的修改，提交和推送"></a>三、子模块的修改，提交和推送</h3><p>子模块就是一个Git项目，你可以认为它和父模块是完全独立的，因此对子模块进行任何修改，你都可以cd到子模块中进行任何跟git相关的操作，包括git commit、git push等等操作都可以。</p>
<p>父模块本质上也不需要感知子模块的修改，当你在子模块改造完之后，在父模块运行<code>git status</code>不会看到子模块具体修改了几个文件，只会告诉你子模块是否进行了修改。当你把子模块的修改内容都push掉了，可以在父模块把修改add上并提交。</p>
<p>通常，除非是子模块不成熟还处于调试阶段，否则不建议在父模块中修改子模块，因为这可能会影响子模块的独立运行和纯洁性。</p>
<h3 id="四、子模块的版本管理"><a href="#四、子模块的版本管理" class="headerlink" title="四、子模块的版本管理"></a>四、子模块的版本管理</h3><p>我个人觉得，直接进入子模块进行<code>git fetch</code>或者<code>git pull</code>是比较直观的方法，你也可以通过在父模块运行如下命令来拉取代码：</p>
<pre><code>git submodule update --remote ${子模块名称}
</code></pre><p>子模块的名称可以在.gitmodules中获取。<br>这个办法不好的地方是会导致子模块的指针变成一个游离的HEAD，需要手动再checkout一次，或者在命令后加上<code>--remote</code>或者<code>--rebase</code>才行。<br>未说明的情况下，拉取的是master的代码，通过设置branch可以设定要跟踪的分支：</p>
<pre><code>git config -f .gitmodules submodule.${子模块名称}.branch stable
</code></pre><p>如果设置了配置选项 status.submodulesummary，那么在父模块运行git status也会显示变更的子模块信息：</p>
<pre><code>git config status.submodulesummary 1    
</code></pre><p>通常，父模块推送的时候需要检查子模块的内容已经推送了与否，我们可以给<code>git push</code>设置参数以进行强制校验：</p>
<pre><code>### 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 push 操作失败
git push --recurse-submodules=check    

### 自动尝试推送子模块然后再推送父模块
git push --recurse-submodules=on-demand
</code></pre><p>如果你觉得<code>on-demand</code>好用的话，可以设置一个别名：</p>
<pre><code>`git config alias.spush &apos;push --recurse-submodules=on-demand&apos;`
</code></pre><h3 id="五、实战：调度2-0迁移"><a href="#五、实战：调度2-0迁移" class="headerlink" title="五、实战：调度2.0迁移"></a>五、实战：调度2.0迁移</h3><p>(<em>其实本段才是文章的重点……</em>)</p>
<p>我们之前开发了一个Base IDE外部版的调度系统，最近大家加班赶内部版D2的项目，调度系统页面也要被重构，不过基于之前的开发经验，我们可以基于外部版的代码来开发。</p>
<p>最大的问题是，如何最大限度复用外部版的代码开发，内部版的很多功能和逻辑有可能和外部版的不一样，但是部分展现和交互的逻辑是一致的，我们当然不希望同一套代码写两次，但是如果在同一个项目中分两套逻辑的话，多少会有点冗余，发布会是一个瓶颈，并且可能没有一个足够好的框架来做这件事情，并且项目周期也很紧。否决了很多了想法之后，我发现了<code>git submodule</code>。下面贴一下我是怎么一步一步迁移过来的。</p>
<p>假设外部版项目叫Base，内部版叫DataWorks，那么先：</p>
<pre><code>1. GitLab上创建空项目DataWorks
2. 按上述方式，在src目录中创建子模块Base
</code></pre><p>这里最折腾的是路径的问题，我们的入口在<code>src</code>下面，有时引入通用包的时候，常常简写为<code>import Table from &#39;components/Table&#39;</code>，这里components文件夹是直接放在<code>src</code>目录下的。我们通过webpack的resolve指定文件路径，tsconfig.json的paths指定查找的根路径。</p>
<p>当引入workbench项目放在<code>src</code>目录下后，整个文件就找不到了，最终通过在webpack的resolve里面<code>添加一条路径</code>以及tsconfig作如下配置解决:</p>
<pre><code>&quot;paths&quot; : {
  &quot;*&quot; : [
    &quot;src/*&quot;,
    &quot;src/base/src/*&quot;
  ]
},
</code></pre><p>这样，当搜索<code>components/Table</code>, 会首先当前项目中搜索<code>src/components/Table</code>时，然后依次查找<code>src/base/src/components/Table</code>是否存在，这样，当新项目没有相应的文件实现时，会查找子模块<code>base</code>中的代码。而新项目若已经有了相应的模块，那么按照优先级，直接在当前的项目中就可以找到。</p>
<p>那么如何进行新代码的复用呢，因为我们的组件大部分都是React.Component，所以可以通过<code>继承和复写</code>的方式来实现新功能。这也要求我们的代码尽量的封装好，实现良好的接口设计。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Lodash debounce和throttle用法和源码解析]]></title>
      <url>/2017/05/19/lodash-debounce-throttle/</url>
      <content type="html"><![CDATA[<h3 id="一、debounce和throttle相同和不同"><a href="#一、debounce和throttle相同和不同" class="headerlink" title="一、debounce和throttle相同和不同"></a>一、debounce和throttle相同和不同</h3><ul>
<li><p>使用场景<br>众所周知，在浏览器端处理事件的监听的函数，很多时候事件会触发的非常频繁，比如浏览器resize，页面scroll，最频繁最常见的恐怕是表单的异步搜索功能，我们不需要每次在事件触发的时候都去执行事件绑定函数，而只需要设置一个时间阈值，来确认是否需要执行绑定事件函数。</p>
</li>
<li><p>debounce<br>debounce的意思为”消抖”, lodash提供了一个实现好的debounce方法，这个方法能保证<strong>在空闲时间大于或等于一个指定的时间间隔的时候才会触发目标函数。</strong> 换句话说，比如设定了250ms为一个空闲时间，则必须在触发事件后的250ms内没有再次触发这个事件，才会执行绑定的目标函数。</p>
</li>
<li><p>throttle<br>throttle的含义为”节流”,lodash同样提供了一个实现好的throttle方法，这个方法的作用是<strong>保证事件触发后，目标函数在指定的时间间隔内调用一次。</strong> 这理解起来可能会更简单一些，同样设定比如250ms的时间间隔，则无论这个事件在这个时间间隔内触发多少次（当然需要 &gt;= 1 次），绑定的目标函数只会调用一次。</p>
</li>
</ul>
<h3 id="二、debounce用法"><a href="#二、debounce用法" class="headerlink" title="二、debounce用法"></a>二、debounce用法</h3><p>详细可参见lodash官网上<a href="https://lodash.com/docs/4.17.4#debounce" target="_blank" rel="external">关于debounce的用法</a>。这里简单提一下：</p>
<p>使用形式大致如下：</p>
<pre><code>_.debounce(func, [wait=0], [options={}]);
</code></pre><p>其中<code>func</code>是要被绑定的函数，wait是毫秒作为单位的时间间隔。</p>
<p>debounce可以接受的options项列举如下：</p>
<pre><code>{
    &lt;boolean&gt;leading : 执行实际函数的时机是在时间间隔刚开始
    &lt;number&gt;maxWait : 最长多少秒必须执行一次,
    &lt;boolean&gt;trailing = true : 执行实际函数的时机是在时间间隔刚结束
}
</code></pre><p>默认情况下，debounce方法的trailing属性设置为true。  </p>
<p>其中<code>leading</code>、<code>trailing</code>的作用单独说明一下，因为网上似乎没有搜到好的解释。这两者都是在确认目标函数可以执行后，设置目标函数执行的位置。<code>leading</code>的含义是”头、领队”，就是说目标函数会在首先执行。<br>举个例子，</p>
<pre><code>onClick = {_.debounce(handler, 1000, {leading: true})}
</code></pre><p>这意味在第一次触发事件的时候，会调用handler，未指定<code>leading: true</code>的情况下，只有在事件结束前才会调用handler。</p>
<p>那么另外一个问题来了，同时设置了<code>leading: true</code>且<code>trailing: true</code>的情况下(就像刚才这个例子，因为有个默认值)，各个情况下如何触发事件呢？</p>
<ul>
<li>点击一次, 立即触发handler，之后不再触发</li>
<li>点击一次之后，立即触发handler，在接下来不到1s内多次点击后，空闲达到1s时，触发一次handler</li>
<li>点击一次之后，立即触发handler，在接下来1s之后再次点击，这就是一个新的循环，再次触发handler</li>
</ul>
<p>如果设置了<code>trailing: false</code>而设置了<code>leading: true</code>，则不会存在上述的第二种情况。</p>
<p>如果同时设置了<code>trailing: false</code>并且<code>leading: false</code>，恭喜你，这个函数将没有任何意义。</p>
<p>debounce方法会返回一个新的函数，这个函数可以直接作为事件监听函数使用。</p>
<h3 id="三、throttle用法"><a href="#三、throttle用法" class="headerlink" title="三、throttle用法"></a>三、throttle用法</h3><p>这里也贴上lodash官网上<a href="https://lodash.com/docs/4.17.4#throttle" target="_blank" rel="external">关于throttle的用法</a>。这里也简单提一下：</p>
<p>使用形式大致如下：</p>
<pre><code>_.throttle(func, [wait=0], [options={}]);
</code></pre><p>和debounce不同的是，throttle只接受<code>leading</code>和<code>trailing</code>两个option项，<code>maxWait</code>的值强制设置的和<code>wait</code>一致（其实也必须一致）。</p>
<p>同样的，throttle方法会返回一个新的函数，这个函数可以直接作为事件监听函数使用。</p>
<h3 id="四、debounce源码解析"><a href="#四、debounce源码解析" class="headerlink" title="四、debounce源码解析"></a>四、debounce源码解析</h3><p>贴源码之前，先提几个关键字：闭包、setTimeout。<br>闭包用来保存和函数运行，时间计算相关的变量和函数。<br>setTimeout用来保证函数在指定的时间之后运行。</p>
<p>先把总体代码框架贴出来再来分析。</p>
<pre><code>function debounce(func, wait, options) {
  var lastArgs,              // 上一次调用debounced的arguments
      lastThis,                // 上一次调用debounced的this引用
      maxWait,               // 最长多久执行一次
      result,                // 绑定函数实际执行的结果 
      timerId,                // 执行setTimeout返回的ticketId
      lastCallTime,          // 上一次调用debounced的时间戳
      lastInvokeTime = 0,    // 上次实际执行函数的时间戳
      leading = false,        // 是否开启了leading控制
      maxing = false,        // 是否开启了maxWait控制
      trailing = true;        // 是否开启了trailing控制

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  /*... inner function code ...*/
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;</code></pre>

<p>首先在debounce函数体内定义了10个局部变量，这些局部变量会在闭包内保存使用。<br>然后是一些参数校验，并设置了<code>leading</code>,<code>maxing</code>,<code>maxWait</code>,<code>trailing</code>的值，请大家留意一下这些值的来源。<br>最后返回的<code>debounced</code>是一个函数，也就是可以被作为事件监听函数使用的函数，这个函数还有两个方法就是<code>cancel</code>和<code>flush</code>,下面也会详细说明。</p>
<pre><code>  /***   debounced   ***/
  function debounced() {
    var time = now(),
        //使用shouldInvoke判断是否需要执行函数
        //其实我想吐槽一下这个命名，明明是shouldInvoke返回的结果，却叫isInvoking
        isInvoking = shouldInvoke(time);

    //每次进来的时候，都把函数的参数和this引用保存下来，并记录时间
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    //如果可以执行，则会判断当前情况从而进入入口函数，其他情况会直接挡掉
    //起初调用的时候，isInvoking为true，timerId也没指定，所以会进入leadingEdge
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
</code></pre>
接下来我们继续看看shouldInvoke函数的作用，这个函数会确定这个事件是不是在合适的时间段发生：
<pre><code>  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    //作者在这写了一坨注释，我直接上我的理解了
    //哪些情况下表明我们需要开启延时计算函数
    //情况1: lastCallTime未定义，其实就是刚执行的时候
    //情况2: 两次执行的时间间隔超过设定的阈值了
    //情况3: 比较特殊吧，暂时没有明白用意何在
    //情况4: 设置了maxWait，并且两次实际执行的时间间隔超过了它
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
</code></pre>
接下来核心的函数来了，判断是否需要在头部这一边执行的函数leadingEdge。  
注意leadingEdge不止会做在leading为true时执行的事情。
<pre><code>  function leadingEdge(time) {
    // 重置lastInvokeTime值
    lastInvokeTime = time;
    // 到下个时间点再说吧，兄弟
    timerId = setTimeout(timerExpired, wait);
    // 如果leading是true，会把目标函数立即执行一下
    return leading ? invokeFunc(time) : result;
  }
</code></pre>
timerExpired也是一个核心函数
<pre><code>  function timerExpired() {
    var time = now();
    // 如果现在可以执行了，那么直接到尾部这边
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // 不能执行的话，看看还有剩余时间
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
</code></pre>

<p>remainingWait用来计算剩下来的时间</p>
<pre><code>  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        //这里其实不应该使用result这个名称的，容易引起误会
        result = wait - timeSinceLastCall;
        //如果设置了maxWait，则是取maxWait和下一个时间Interval最近的时间点
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }
</code></pre>
对应于leadingEdge的，trailingEdge的实现如下：
<pre><code>  function trailingEdge(time) {
    //清除timerId值
    timerId = undefined;
    //作者使用了lastArgs字段表明至少执行过了一次debouced
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    //执行完毕后，清空lastArgs和lastThis
    lastArgs = lastThis = undefined;
    return result;
  }
</code></pre>
最后一个关键的函数，立即执行被绑定的函数
<pre><code>  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    //记录上次执行的时间
    lastInvokeTime = time;
    //立即执行这个函数，返回结果，注意这个result就是上面那个闭包变量
    result = func.apply(thisArg, args);
    return result;
  }
</code></pre>

<p>最后，还有两个被暴露出来的工具方法（用的很少）</p>
<pre><code>  /**取消执行绑定的函数**/
  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }
  /**立即调用绑定的函数，获取结果**/
  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }
</code></pre>

<h3 id="五、throttle源码解析"><a href="#五、throttle源码解析" class="headerlink" title="五、throttle源码解析"></a>五、throttle源码解析</h3><p>lodash的throttle源码非常的简单。</p>
<pre><code>function throttle(func, wait, options) {
  var leading = true,
      trailing = true;  
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
module.exports = throttle;
</code></pre>

<p>默认情况下，throttle其实就是<strong>设置了leading为true，且maxWait值和wait值一致的debounce函数。</strong>当然你也可以设置leading或者trailing为false，但至少要保证他们都不为false。</p>
<h3 id="六、其他实现"><a href="#六、其他实现" class="headerlink" title="六、其他实现"></a>六、其他实现</h3><p>lodash不是唯一提供debounce和throttle的库，你可以使用别的库提供的方法，使用原生的JavaScript也未尝不可。  </p>
<ol>
<li>UnderScore实现 <a href="https://github.com/jashkenas/underscore" target="_blank" rel="external">https://github.com/jashkenas/underscore</a>   </li>
<li>jQuery插件实现 <a href="https://github.com/cowboy/jquery-throttle-debounce" target="_blank" rel="external">https://github.com/cowboy/jquery-throttle-debounce</a>  </li>
<li>原生JavaScript实现 <a href="http://www.css88.com/archives/4648" target="_blank" rel="external">http://www.css88.com/archives/4648</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript元编程]]></title>
      <url>/2017/05/15/js-metaprog/</url>
      <content type="html"><![CDATA[<p>最近稍微花了点时间，抛开业务研究了一下技术。这里结合之前学习过Java的一点经验，简单的谈一下元编程。</p>
<h4 id="1-何谓元编程"><a href="#1-何谓元编程" class="headerlink" title="1.何谓元编程"></a>1.何谓元编程</h4><p>元编程简单说就是“编写代码的代码”，换个高雅解释即是“元编程是编写在运行时操纵语言构件的代码”。</p>
<p>估计还是有人没看懂，这里再换一种说法解释：<strong>”一门语言拥有对自身的元编程能力就表现在反射“</strong>。大家应该都知道了吧。</p>
<p>用过Java的都知道反射的好处，它提供了在代码运行阶段动态执行代码的可能。反射和代理可以结合起来使用使得代码更富于动态性。举个例子，常见的Web框架如Spring、Struts等，都是以XML的方式让开发者动态配置执行类和执行方法，在运行期间，再通过反射和代理的方式运行代码。</p>
<p>有人说，JavaScript本身就是动态语言，为何还要强调元编程呢，不要急，请看我慢慢道来。</p>
<h4 id="2-JavaScript的代理模式"><a href="#2-JavaScript的代理模式" class="headerlink" title="2.JavaScript的代理模式"></a>2.JavaScript的代理模式</h4><p>在ES6中，引入了代理类，具体细节不多说，这里只描述一下重点。<br>常见的代理是如此写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = new Proxy(被代理的对象, &#123;</div><div class="line">  get: function (target, key, receiver) &#123;</div><div class="line">    // 返回被代理修改过的值</div><div class="line">    return ...</div><div class="line">  &#125;,</div><div class="line">  set: function (target, key, value, receiver) &#123;</div><div class="line">    // 通过此方法拦截修改值</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.a = 1; // invoke set function</div><div class="line">console.log(obj.b) // invoke get function</div></pre></td></tr></table></figure>
<p>常见的Proxy拦截的目标列表如下：</p>
<ul>
<li><code>get</code> 拦截对象属性的读取</li>
<li><code>set</code> 拦截对象属性的设置</li>
<li><code>has</code> 拦截对 in 的操作</li>
<li><code>delete</code> 拦截对 delete 的操作</li>
<li><code>ownKeys</code> 主要拦截Object.keys 方法</li>
<li><code>apply</code> 拦截所有主动调用方法，直接调用、call、apply都会被拦截</li>
<li><code>construct</code> 拦截 new 操作<br>还有 <code>getOwnPropertyDescriptor</code>、<code>defineProperty</code>、<code>preventExtensions</code>、<code>getPrototypeOf</code>、<code>isExtensible</code>、<code>setPrototypeOf</code>都是对同名的方法进行拦截。</li>
</ul>
<h4 id="3-JavaScript的反射"><a href="#3-JavaScript的反射" class="headerlink" title="3. JavaScript的反射"></a>3. JavaScript的反射</h4><p>JavaScript作为一门动态语言，本身其实已经支持了类似Java的Reflect方法，不过在ES6中，仍然提供了Reflect这个反射类。</p>
<p>本身Reflect不会提供新功能，官方指出，提供Reflect主要目的有以下几点：</p>
<ol>
<li>是把ES5中类似Object.defineProperty的方法移入Reflect中</li>
<li>是重构一些Object已有的方法，使得参数和返回值理解起来更加合理。</li>
<li>通过Reflect的方式替换掉 in 和 delete 的操作符</li>
<li><strong>搭配Proxy，无论通过Proxy怎么设置行为，都可以通过Reflect下相应方法来执行原生方法。</strong><br>举个例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var handlers = &#123;</div><div class="line">  get(target,key,context) &#123;</div><div class="line">    console.log( &quot;accessing: &quot;, key );</div><div class="line">    // 这里通过Reflect.get来获取真正的值，不然是循环引用了</div><div class="line">    return Reflect.get(</div><div class="line">      target, key, context</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>值得留意的一点是，Reflect.ownKeys是一定按照顺序列出可枚举的属性的，顺序如下：<br>i. 首先，如果索引是整数，升序。<br>ii. 其次，根据来根据索引String创建排序。<br>iii. 最后，根据Symbol创建顺序。<br>在 ES6 中，<code>Reflect.ownKeys(..)</code>，<code>Object.getOwnPropertyNames(..)</code>，<code>Object.getOwnPropertySymbols(..)</code>的顺序是可靠可预测的，因此它是安全的。</p>
<h3 id="4-JavaScript元编程"><a href="#4-JavaScript元编程" class="headerlink" title="4. JavaScript元编程"></a>4. JavaScript元编程</h3><p>刚才所列举的，Proxy和Reflect都是在元级别进行自定义行为（比如属性查找，赋值，枚举，函数调用等），这里也顺便强调一下<strong>包装</strong>和<strong>代理</strong>之间的区别，简单的理解起来，<strong>包装</strong>是新增，<strong>代理</strong>是修改。</p>
<p>这里举一个例子说明一下元编程几个简单的示例：  </p>
<h4 id="1-没有找到这样的属性或者方法"><a href="#1-没有找到这样的属性或者方法" class="headerlink" title="1. 没有找到这样的属性或者方法"></a>1. 没有找到这样的属性或者方法</h4><p>我们访问JavaScript对象的某一个属性，有可能因为拼写错误或者不确定是否为空，需要先判断。这里可以通过元编程的方式给出友善的提醒，或者直接赋上一个默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">        a: 1,</div><div class="line">    &#125;,</div><div class="line">    handlers = &#123;</div><div class="line">        get(target,key,context) &#123;</div><div class="line">            if (Reflect.has(target, key)) &#123;</div><div class="line">                return Reflect.get(</div><div class="line">                    target, key, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                throw &quot;No such property/method!&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        set(target,key,val,context) &#123;</div><div class="line">            if (Reflect.has(target, key)) &#123;</div><div class="line">                return Reflect.set(</div><div class="line">                    target, key, val, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                throw &quot;No such property/method!&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    pobj = new Proxy( obj, handlers );</div><div class="line"></div><div class="line">pobj.a = 3;	// 没问题</div><div class="line"></div><div class="line">pobj.b = 4;  // Error: No such property/method!</div><div class="line">pobj.bar();  // Error: No such property/method!</div></pre></td></tr></table></figure>
<h4 id="2-多重继承"><a href="#2-多重继承" class="headerlink" title="2. 多重继承"></a>2. 多重继承</h4><p>我们可以通过指定Symbol的方式，搭配get方法实现多重继承的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">var obj1 = &#123;</div><div class="line">        name: &quot;obj-1&quot;,</div><div class="line">        foo() &#123;</div><div class="line">            console.log( &quot;obj1.foo:&quot;, this.name );</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">    obj2 = &#123;</div><div class="line">        name: &quot;obj-2&quot;,</div><div class="line">        foo() &#123;</div><div class="line">            console.log( &quot;obj2.foo:&quot;, this.name );</div><div class="line">        &#125;,</div><div class="line">        bar() &#123;</div><div class="line">            console.log( &quot;obj2.bar:&quot;, this.name );</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    handlers = &#123;</div><div class="line">        get(target,key,context) &#123;</div><div class="line">            if (Reflect.has( target, key )) &#123;</div><div class="line">                return Reflect.get(</div><div class="line">                    target, key, context</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            // 核心在这里，强制get方法查找原型链数组里面的方法</div><div class="line">            else &#123;</div><div class="line">                for (var P of target[</div><div class="line">                    Symbol.for( &quot;[[Prototype]]&quot; )</div><div class="line">                ]) &#123;</div><div class="line">                    if (Reflect.has( P, key )) &#123;</div><div class="line">                        return Reflect.get(</div><div class="line">                            P, key, context</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    obj3 = new Proxy(</div><div class="line">        &#123;</div><div class="line">            name: &quot;obj-3&quot;,</div><div class="line">            baz() &#123;</div><div class="line">                this.foo();</div><div class="line">                this.bar();</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        handlers</div><div class="line">    );</div><div class="line"></div><div class="line">// 创建自定义的原型链</div><div class="line">obj3[ Symbol.for( &quot;[[Prototype]]&quot; ) ] = [</div><div class="line">    obj1, obj2</div><div class="line">];</div><div class="line"></div><div class="line">obj3.baz();</div></pre></td></tr></table></figure>
<h4 id="3-转变链式操作"><a href="#3-转变链式操作" class="headerlink" title="3. 转变链式操作"></a>3. 转变链式操作</h4><p>通过Proxy的get方法，我们可以把函数执行变成链式的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var pipe = (function () &#123;</div><div class="line">  return function (value) &#123;</div><div class="line">    var funcStack = [];</div><div class="line">    var oproxy = new Proxy(&#123;&#125; , &#123;</div><div class="line">      get : function (pipeObject, fnName) &#123;</div><div class="line">        if (fnName === &apos;get&apos;) &#123;</div><div class="line">          return funcStack.reduce(function (val, fn) &#123;</div><div class="line">            return fn(val);</div><div class="line">          &#125;,value);</div><div class="line">        &#125;</div><div class="line">        funcStack.push(window[fnName]);</div><div class="line">        return oproxy;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return oproxy;</div><div class="line">  &#125;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">var double = n =&gt; n * 2;</div><div class="line">var pow    = n =&gt; n * n;</div><div class="line">var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;</div><div class="line"></div><div class="line">pipe(3).double.pow.reverseInt.get; // 63</div></pre></td></tr></table></figure>
<h4 id="4-使用负值获取数组成员"><a href="#4-使用负值获取数组成员" class="headerlink" title="4. 使用负值获取数组成员"></a>4. 使用负值获取数组成员</h4><p>有些数组方法允许你通过 -1 获取数组最后一个元素，倒数第二个通过 -2 ，我们可以通过重写get方法实现这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function createArray(...elements) &#123;</div><div class="line">  let handler = &#123;</div><div class="line">    get(target, propKey, receiver) &#123;</div><div class="line">      let index = Number(propKey);</div><div class="line">      if (index &lt; 0) &#123;</div><div class="line">        propKey = String(target.length + index);</div><div class="line">      &#125;</div><div class="line">      return Reflect.get(target, propKey, receiver);</div><div class="line">     &#125;</div><div class="line">  &#125;;</div><div class="line">  // 把数组用 proxy 包裹一层</div><div class="line">  let target = [];</div><div class="line">  target.push(...elements);</div><div class="line">  return new Proxy(target, handler);</div><div class="line">&#125;</div><div class="line">let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</div><div class="line">console.log(arr[-1]); // c</div></pre></td></tr></table></figure>
<p>其他还有各种各样的用法，比如数据绑定、Http Mock、记录日志和执行时间等等，甚至是用纯JS实现DOM。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>通过ES6的Proxy和Reflect，我们可以实现很多可能性，当然部分还是处于实践中的状态，有问题或者更好的想法，欢迎大家一起来探讨研究。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[React以及React生命周期]]></title>
      <url>/2017/04/18/react-lifecycle/</url>
      <content type="html"><![CDATA[<p>这篇文章简单总结我使用React以来对其生命周期的一些理解。</p>
<h2 id="一、React原理"><a href="#一、React原理" class="headerlink" title="一、React原理"></a>一、React原理</h2><p>在介绍React生命周期之前，有必要先介绍一下React框架的基本工作原理，这样再解释起来会更快一点。</p>
<p>正如很多文章所说的，React并不是一个大一统的MVC框架，它只是一个View层。</p>
<p>React的核心是组件 + 虚拟DOM，通过组件 <strong>render</strong> 方法返回的生成虚拟DOM代码的逻辑，和上次render返回的结果作Diff比较，并计算出到底应该渲染哪一个实际DOM，此乃React框架的核心概念和算法。</p>
<p>React一个重要特点是高度组件化，一个页面上所有展示的内容都可以化成各式各样的组件，每个组件都负责内部的渲染逻辑。彼此之间，在数据流不相关的情况下，互不干扰。通常来说，React的组件都是可重用可维护的。</p>
<p>React另一个特点是单向的数据流，父组件和子组件之间可以通过state和props传递信息，而子组件和子组件之间只能通过父组件通信，在某种程度上会简化代码逻辑，但是也可能会导致编程的复杂。</p>
<p>某种意义上来说，React和直接操作DOM的库如jQuery是冲突的，不过React仍然会遵循使用者的意愿，即当虚拟节点生成的DOM被操作过后，以后都不会再去管理这个DOM。不过这种事还是尽量少做。</p>
<p>React所有组件都遵循一套统一的规范，如果说render方法是每一个组件的灵魂，那么作为钩子的那些生命周期函数可以作为躯体来使组件成为一个完整的组件。下文会综合整理一下相关的内容。</p>
<h2 id="二、组件初始化"><a href="#二、组件初始化" class="headerlink" title="二、组件初始化"></a>二、组件初始化</h2><p>一个通常的React组件(继承了React.Component)，在<strong>初始化</strong>时会<strong>按顺序</strong>经历如下阶段：  </p>
<ol>
<li><code>constructor(initProps)</code><br>这个方法只会调用一次，组件刚刚生成的时候调用，这里可以通过 this.state = { xxx } 来初始化state。  </li>
<li><code>componentWillMount()</code><br>这个方法只调用一次，在执行render方法前执行，在这个方法里可以通过this.setState()方法设置一个初始state,不过用处不大，似乎这样的写法比较少。  </li>
<li><code>render()</code><br>在执行完willMount后会通过执行render方法生成虚拟DOM并进一步生成实际DOM挂载到实际的HTML文档上。  </li>
<li><code>componentDidMount()</code><br>这个方法只调用一次，在执行render方法后执行，此时真实DOM了已经存在了，此方法里面调用this.setState()将会把新state修改提交到render队列中(关于render的机制下文会说)通常来说，异步Fetch初始数据等初始化操作都会放在此钩子函数中调用。</li>
</ol>
<p>值得一提的是，通过React.createClass()方法还有可以有下面两个方法：<br><code>getDefaultProps()</code><br><code>getInitState()</code><br>两个方法都return一个对象作为初始的Props或者State，在ES6写法中这两个方法是不被支持的，初始化state，可以在constructor中指定。指定默认的props，可以在组件代码中按如下方式书写：  </p>
<pre><code>static defaultProps = { 
    //default Props
};</code></pre>

<h2 id="三、组件更新"><a href="#三、组件更新" class="headerlink" title="三、组件更新"></a>三、组件更新</h2><p>触发组件更新的方法主要有两种：一是组件自身state变化，二是父组件传递进来的props变化。<br>props和自身state变化区别是，多了这么一个函数:<br><code>componentWillReceiveProps(nextProps)</code><br>这个函数内，this.props代表当前的props状态，nextProps是接受到props状态，这也是React组件唯一可以感知到props变化的函数。<br>通常这里会有一些和父组件相关的，比如某个props改变需要导致重新Fetch数据，这里去做操作的时候一定需要注意避免循环改变导致的无限渲染，这里可能就涉及到比较props几个属性来决定是否要setState()或者通过方法修改父组件props(在Redux中需要额外注意)。<br><code>shouldComponentUpdate(nextProps, nextState)</code><br>这个用来判断是否需要执行下面列出的方法。也许是非常重要的函数，了解React渲染的机制的同学应该都了解，React的render方法可能会被频繁的调用，计算整个内存DOM树和Diff也是需要花费时间的，特别是根组件下面的render，设计的不好会导致前端运行效率大幅度降低。虽然通常情况下不需要手动实现这个方法 (默认返回<code>true</code>) 。<br>React提供了PureComponent，它提供了默认的一种非常简单的shouldComponentUpdate实现，仅仅去把Props和State作一层浅比较，通过迭代比较对象的keys并在对象的key值不严格相等时返回false。很多时候，此功能并不能完全的满足我们的需求，而如果对对象进行深层次的递归遍历比较，成本又会很大，甚至会导致性能的进一步下降，在state或者props非常庞大的时候，可以考虑使用<a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js</a>。<br><code>componentWillUpdate(nextProps, nextState)</code><br>这个方法会在组件触发render前执行，这个方法里面不要做setState的操作，大部分时候这个函数是可选的，按需要实现。<br><code>render</code><br>所以这一步终于到了render。<br><code>componentDidUpdate(preProps, preState)</code><br>这个函数目前发现有两点用处，一是作为子组件render完的标志通知父组件，不过一定要小心循环调用。还有一点是理解为子组件更新状态后的componentDidMount方法，此时新生产的DOM已经存在了，可以做一些额外的操作(比如scrollIntoView之类的…)</p>
<h2 id="四、组件销毁"><a href="#四、组件销毁" class="headerlink" title="四、组件销毁"></a>四、组件销毁</h2><p>组件销毁可能有两种情况，第一种是其自身在父组件被移除了，还有一种是设置了key属性，父组件在render的时候，发现这个组件key值变了，那么原来的会被销毁掉，生成一个新的。<br><code>componentWillUnmount()</code><br>这个函数会在组件被移除前调用，此时DOM还是存在的，一般是在这里做一些清除扫尾的工作，比如清除掉定时器。</p>
<h2 id="五、关于setState和render"><a href="#五、关于setState和render" class="headerlink" title="五、关于setState和render"></a>五、关于setState和render</h2><p>和React打交道，永远不可能摆脱这两个方法，下面奉上我的理解。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>调用setState是有原则的，不能在render中调用，在<code>componentWillUpdate</code>和<code>componentDidUpdate</code>中调用需要注意时机以避免死循环。<br>React有一个state队列来管理需要改变的state，每次通过setState,实质上是把新的state扔进了state队列里面，每隔一段时间，React检查state队列里面的内容，并将其作合并操作，合并的结果会触发组件更新的一系列方法(即使新state和上一个state一样)。<br>所以虽然不建议在一个组件里面同步的调用多次setState，但是因为有了这种机制，也不会导致多次render的情况。<br>setState还有第二个参数，是一个callback，用于在此次setState导致的<code>componentDidUpdate</code>之后再次调用。不过值得一提的是如果<code>shouldComponentUpdate</code>返回了false，这个callback仍然会被调用。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>通过调用render返回的虚拟DOM或许是React最耗时的操作，很多时候，我们应该简化render方法或者减少render的不必要调用，在非常庞大的项目下，实现<code>shouldComponentUpdate</code>应该是必不可少的。另外，对于那种异步搜索框，可以使用lodash的<code>throttle</code>方法或者<code>debounce</code>方法减少请求和render次数。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>React的入门门槛很低，但是去做大项目的架构设计，还是很需要认真思考的。<br>复杂可能包括三个方面：<br>一个是数据流设计，这是核心，也是灵魂。<br>一个是页面上View组件的架构，组件之间的彼此关系。<br>一个是View组件的实现，现在集团有AntD和Fusion提供了很多组件的实现，可以在上面包装一层成为自己的业务组件。<br>使用React开发出一个健壮、高性能的复杂页面，还是相当具有挑战的。</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用TypeScript集成React]]></title>
      <url>/2017/04/16/react-typescript/</url>
      <content type="html"><![CDATA[<h3 id="一、Webpack项目添加TypeScript支持"><a href="#一、Webpack项目添加TypeScript支持" class="headerlink" title="一、Webpack项目添加TypeScript支持"></a>一、Webpack项目添加TypeScript支持</h3><ol>
<li><p>安装npm包 </p>
<pre><code>tnpm i --save  @types/react @types/react-dom
tnpm i --save-dev ts-loader
</code></pre></li>
</ol>
<ol>
<li><p>webpack配置文件，添加对后缀名的识别</p>
<pre><code>resolve: {
    extensions: [&apos;&apos;, &apos;.webpack.js&apos;, &apos;.web.js&apos;, &apos;.ts&apos;, &apos;.tsx&apos;, &apos;.js&apos;]
  }
</code></pre></li>
</ol>
<ol>
<li><p>webpack添加loader，添加对ts和tsx文件的解析</p>
<pre><code>loaders: [{
        test: /\.tsx?$/,
        loader: &apos;ts-loader&apos;
  }],                  
</code></pre></li>
</ol>
<ol>
<li><p>项目根路径下添加tsconfig.json文件，配置项参见<a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="external">官方文档</a></p>
<p> 这里直接不劳而获的贴出网上流行的内容：</p>
<pre><code>{
  &quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;./build/&quot;,
    &quot;sourceMap&quot;: true,
    &quot;noImplicitAny&quot;: true,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;target&quot;: &quot;es5&quot;,
    &quot;jsx&quot;: &quot;react&quot;
  },
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ]
} 
</code></pre></li>
</ol>
<ol>
<li>在这之后，可以在项目中直接写 ts 或者 tsx 文件了，会和其他的jsx文件一同以es5的形式被编译到pages文件里面。    </li>
</ol>
<h3 id="二、VSCODE集成ESLint和TSLint"><a href="#二、VSCODE集成ESLint和TSLint" class="headerlink" title="二、VSCODE集成ESLint和TSLint"></a>二、VSCODE集成ESLint和TSLint</h3><p>其实之前我IDE一直用的Webstorm，直到某一天项目再也打不开了……<br>VSCode一个好处是比Webstorm轻，没有很多不需要的功能，不像Webstorm需求的内存那么大，另外一点是很多必备的功能（如原生支持JSX、ES6等）都已经集成了，而且插件库来说还是比较全的。  </p>
<ul>
<li>支持<code>ESLint</code></li>
</ul>
<p>只需要安装<code>ESLint</code>这个插件即可。工程下已经有相应的.eslintrc文件和devDependencies了。</p>
<ul>
<li>支持<code>TSLint</code></li>
</ul>
<p><code>TSLint</code>是TypeScript的Lint文件。</p>
<ol>
<li>先安装： <code>tnpm install --save-dev tslint</code>    </li>
<li>再安装插件：<code>TSLint</code>   </li>
<li>最后在项目下新建一个tslint.json文件，这是规则文件，可以参考<a href="https://github.com/palantir/tslint/blob/master/tslint.json" target="_blank" rel="external">https://github.com/palantir/tslint/blob/master/tslint.json</a> 这里的例子。  </li>
<li>此时编辑器已经对你的ts或者tsx文件开始进行检查了。  </li>
</ol>
<h3 id="三、使用TSX一些额外注意的地方："><a href="#三、使用TSX一些额外注意的地方：" class="headerlink" title="三、使用TSX一些额外注意的地方："></a>三、使用TSX一些额外注意的地方：</h3><h4 id="1-类型断言"><a href="#1-类型断言" class="headerlink" title="1. 类型断言"></a>1. 类型断言</h4><p>使用纯TypeScript，可以对类型进行断言:</p>
<pre><code>let foo: any = &apos;just a string&apos;;
let bar: number = (&lt;string&gt;foo).length;
</code></pre><p>此时会告诉编译器，请把any类型的foo当作string类型看待(不论是不是string)，但是在tsx文件中，只能使用<code>as</code>进行断言：</p>
<pre><code>let foo: any = &apos;just a string&apos;;
let bar: number = (foo as string).length;
</code></pre><p>这个问题主要还是因为对尖括号的识别引起的。所有遇到类型断言的地方，都应该使用<code>as</code>替代左右尖括号。</p>
<p>PS: 泛型并不需要，因为语法解析的时候可以正确的识别尖括号里面的是泛型还是DOM元素。</p>
<h4 id="2-React-Class写法"><a href="#2-React-Class写法" class="headerlink" title="2. React Class写法"></a>2. React Class写法</h4><p>所有React组件类都需要继承这一个类：</p>
<pre><code>React.Component&lt;IAppProps, IAppState&gt;
</code></pre><p>其中必须使用泛型<code>IAppProps</code>和<code>IAppState</code>,分别指定了<code>props</code>的类型和<code>state</code>的类型，应该可以使用interface的方式指定约束，这样编辑器在访问<code>props</code>,<code>state</code>属性以及<code>setState</code>,<code>nextProps</code>等的时候都能进行校验(你也可以指定any放弃校验，或者根本不需要使用时)，这样就把propType的校验提前到编译阶段了。</p>
<p>render方法是这么定义的：</p>
<pre><code>public render(): JSX.Element { 

     /** Render Code **/

}
</code></pre><p>其中返回类型是可以不用写的，因为父类已经定义好了返回类型。</p>
<p>参考Antd的写法，一般来说这些类型定义都放在同一个文件中。        </p>
<h4 id="3-结合Redux或者其他第三方库"><a href="#3-结合Redux或者其他第三方库" class="headerlink" title="3. 结合Redux或者其他第三方库"></a>3. 结合Redux或者其他第三方库</h4><p>现在比较流行的库都自带了<code>xxx.d.ts</code>文件来定义一些元数据，如果没有，可以在npm仓库搜索<code>@types/xxx</code>下载相应的元数据文件(比如一开始需要安装的<code>@types/react</code>等等)。</p>
<p>redux自带了index.d.ts文件，提供了常见一些redux方法的实现，比如<code>applyMiddleware</code>等等，至于写action和reducer，则完全遵从TypeScript的规范即可。</p>
<h3 id="四、其他补充"><a href="#四、其他补充" class="headerlink" title="四、其他补充"></a>四、其他补充</h3><p>总体来说感觉TypeScript能规范不少代码规则，提高开发和Review的效率，更多的东西，正在不断的探索和研究中……</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[丑化你的JS代码]]></title>
      <url>/2017/02/13/uglifyjs/</url>
      <content type="html"><![CDATA[<p>UglifyJS，即压缩JavaScript代码。作为前端开发，我们通常都会在发布代码前，对HTML、CSS、JavaScript代码进行一次压缩，精简代码大小，并且防止源代码泄露。在Webpack出现后，我们可以直接用webpack.optimize.UglifyJsPlugin来进行最终的代码压缩，这篇文章会简单分析一下UglifyJS的工作原理，并说明UglifyJS到底会做什么事情。</p>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><p>任何一个编译器不能避免的操作首先是对代码进行词法分析，通过逐个扫描代码字符识别到关键词、注释、操作符、变量、字符串和数字等等，一个直观的词法分析作用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var target = 985;</div><div class="line"></div><div class="line">// 词法分析后的结果</div><div class="line">[</div><div class="line">  &quot;var&quot; : &quot;keyword&quot;,</div><div class="line">  &quot;target&quot; : &quot;identifier&quot;,</div><div class="line">  &quot;=&quot;   : &quot;assignment&quot;,</div><div class="line">  &quot;985&quot;  : &quot;integer&quot;,</div><div class="line">  &quot;;&quot;   : &quot;eos&quot; (end of statement)</div><div class="line">]</div></pre></td></tr></table></figure>
<h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2. 语法分析"></a>2. 语法分析</h3><p>词法分析之后就是语法分析，具体来说，就是来识别语句具体是什么意义，如果词法定义了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">主语: &quot;猫&quot; | &quot;狗&quot;;</div><div class="line">谓语: &quot;吃&quot; | &quot;喝&quot;;</div><div class="line">宾语: &quot;食物&quot; | &quot;水&quot;</div></pre></td></tr></table></figure>
<p>如果我定义一个语法是”主语 谓语 宾语”，那么“猫 喝 水”就是合法的语句，而“猫 吃 喝”虽然能通过词法检查，但是因为找不到合适的语法规则，所以会报出语法解析错误。<br>通常，我们会通过构建AST(Abstract Syntax Tree，抽象语法树)来分析语法，我们把每一个词法识别出来的字符作为树上的节点元素，这是整个编译器里面最重要的环节。<br>接上面词法分析的结果, 语法分析的结果示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  operation: &quot;=&quot;,</div><div class="line">  left: &#123;</div><div class="line">    keyword: &quot;var&quot;,</div><div class="line">    right: &quot;target&quot;</div><div class="line">  &#125;</div><div class="line">  right: &quot;985&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常用的JS词法和语法分析工具有<a href="https://github.com/zaach/jison" target="_blank" rel="external">Jison</a>(CoffeeScript), 还有<a href="https://github.com/mishoo/cl-uglify-js" target="_blank" rel="external">Cl-Uglify-Js</a>(UglifyJS)等。</p>
<h3 id="3-UglifyJS的规则"><a href="#3-UglifyJS的规则" class="headerlink" title="3.UglifyJS的规则"></a>3.UglifyJS的规则</h3><p>本文的重点是这一部分，会列举在识别到什么样的语法时，进行什么样的精简操作。<br>不过要注意的是每个Uglify的实现都是不一样的，大家都会遵循一些基础的原则，某些情况下可以更智能的转化：</p>
<h4 id="1-变量名称的混淆原则"><a href="#1-变量名称的混淆原则" class="headerlink" title="(1) 变量名称的混淆原则"></a>(1) 变量名称的混淆原则</h4><p>规则： 只有作用域上面的变量名称可以被混淆，全局变量名称不可被混淆。<br>解释： 全局变量相关的有可能被别的文件所引用，故不能混淆。</p>
<p>规则： 函数的参数名称可以混淆。<br>解释： 函数参数本质上就是出于局部作用域上的变量，故可以混淆。</p>
<p>规则： 使用eval生成的代码不能被混淆。<br>解释： 不用解释……</p>
<p>规则： 使用了with定义的作用域内部的变量不会被混淆。<br>解释： 因为使用with定义的作用域内部，无法在编译时期确定到底访问的是哪一个变量，故不能混淆。</p>
<h4 id="2-变量名混淆的优先级"><a href="#2-变量名混淆的优先级" class="headerlink" title="(2) 变量名混淆的优先级"></a>(2) 变量名混淆的优先级</h4><p>规则： 字母优先级”etnrisouaflchpdvmgybwESxTNCkLAOM_DPHBjFIqRUzWXV”。<br>解释： 据说这样可以使GZip生成的代码体积更小。</p>
<p>规则： 当前作用域不同变量混淆后的变量名不能重复，同时混淆后的名字不能是关键字。<br>解释： 所有的混淆都是基于作用域来定了，一个作用域下混淆过的变量名要按照优先级顺序拼装。</p>
<h4 id="3-表达式的压缩"><a href="#3-表达式的压缩" class="headerlink" title="(3) 表达式的压缩"></a>(3) 表达式的压缩</h4><p>规则： 如果表达式的结果可以提前计算，并且生成体积会小于原来表达式，则可以执行提前计算。<br>举例： <code>var expr1 = 3 + 5</code> 会被压缩成 <code>var expr1 = 8</code><br>举例： <code>var expr1 = 1 / 3</code> 不会被压缩成 <code>var expr1 = 0.333333...</code>， 因为计算过后的结果长度会明显大于前面的表达式。</p>
<p>规则： true会转化成!0, false会转化成!1<br>解释： 很显然按照此种方式可以缩短2-3个字符，并且不影响后面的比较</p>
<p>规则： 利用短路特性预计算 &amp;&amp; 和 || 表达式的结果<br>举例： true &amp;&amp; say() 会被压缩成 A()</p>
<p>规则： 尽量使用二元操作符替换赋值表达式<br>举例： var a = a + b 会被压缩成 var a += b;</p>
<h4 id="4-函数的压缩"><a href="#4-函数的压缩" class="headerlink" title="(4) 函数的压缩"></a>(4) 函数的压缩</h4><p>规则： 去除没有使用的函数参数<br>举例： <code>function abc(a, b, c){ console.log(a, b) }</code> 会被压缩为 <code>function(a, b){console.log(a, b)}</code></p>
<p>规则： 去除根本不会执行的while循环：while(false){}<br>解释： 也不排除有人会写这种代码…</p>
<p>规则： while(true)变成for(;;)<br>解释： 少写4个字符…</p>
<p>规则： 多个变量定义可以合并成一句话<br>举例： <code>function A(){ var a; var b; var c;}</code> 会被压缩为 <code>function A(){var a,b,c;}</code><br>解释： 很多JS编译器都会做这种事情，因为JS本来就是有变量定义提升的功能。</p>
<p>规则： 如果if/else其中一个块为空，另一个块只有一条语句，则可以化成||或者&amp;&amp;的表达式。<br>举例： <code>if (A){ B(); }</code> 会被压缩成 <code>A&amp;&amp;B();</code></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>其实之前自己刚接触前端时，很好奇Js代码是怎么压缩的。现在想想其实做的事情也不麻烦，主要是定义足够的语法规则，并且需要使用一些额外的变量来存放一些使用过的变量名，我们会使用BeautifyJS来格式化自己的代码，UglifyJS来压缩自己的代码，可能大家会谈很多原则用来如何优雅的写代码，我这篇文章也算从机器的角度来解释压缩的作用。</p>
]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react-intl]]></title>
      <url>/2017/01/20/react-intl/</url>
      <content type="html"><![CDATA[<p>最近在搭建一个新项目框架的时候，因为做之前一个项目时体会过没有预先做国际化的大坑，故这次好好的研究了一下React的国际化框架。下面进入正文。</p>
<p>我们做前端国际化，一般是会有如下的需求：</p>
<ul>
<li>基本功能，使用key代替字符串</li>
<li>能够使用占位符</li>
<li>能够提供默认字符串，帮助前端快速定位到代码中debug</li>
<li>对于英美国家，提供名词的复数功能</li>
</ul>
<p><strong><a href="https://github.com/yahoo/react-intl" target="_blank" rel="external">React-Intl</a></strong> 是迄今最著名的React国际化框架，由Yahoo的程序员开发，到此篇文章发出之时，GitHub上已有3700+的Star数，可以说是和React集成最出名的一套国际化框架，不过正因为如此，它也有很多缺点，这里会先列举出它的强大功能和各种用法，缺点后面再提。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>这里假设你已经有了Webpack + ES6 + React的框架。</p>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>直接安装npm包：  <figure class="highlight plain"><figcaption><span>install react-intl --save```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2.创建资源文件</div><div class="line">以类似如下的形式创建资源文件：  </div><div class="line">&lt;pre&gt;&lt;code&gt;&amp;lt;!--locale/en_US.js--&amp;gt; </div><div class="line">export default(&#123;</div><div class="line">	question : &apos;你是希尔瑞斯吗？&apos;</div><div class="line">&#125;);</div><div class="line">&amp;lt;!-- locale/zh_CN.js --&amp;gt;</div><div class="line">export default(&#123;</div><div class="line">	question : &apos;Are you serious？&apos;</div><div class="line">&#125;);</div><div class="line">&lt;/code&gt;&lt;/pre&gt;</div><div class="line"></div><div class="line">#### 3.包裹你的App</div><div class="line">这里假设使用一个名叫Skeleton.jsx的文件包裹你的App组件。</div><div class="line">&lt;pre&gt;&lt;code&gt;import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; IntlProvider, addLocaleData &#125; from &apos;react-intl&apos;;</div><div class="line">//引入你的资源文件</div><div class="line">import en_US from &apos;locale/en_US&apos;;</div><div class="line">import zh_CN from &apos;locale/zh_CN&apos;;  </div><div class="line">//如果要使用英文以外的语言话，需要先调用内置的addLocaleData方法添加进来，否则会报错</div><div class="line">import zhLocaleData from &apos;react-intl/locale-data/zh&apos;;</div><div class="line">addLocaleData(zhLocaleData);  </div><div class="line">//Skeleton可以封装App的一些框架级别的逻辑</div><div class="line">class Skeleton extends Component&#123;</div><div class="line">	//balabala....</div><div class="line">	render()&#123;</div><div class="line">		return (</div><div class="line">			&amp;lt;IntlProvider locale=&#123;语言名称，比如&apos;en&apos;||&apos;zh&apos;&#125;</div><div class="line">			              messages=&#123;资源文件，比如import进来的en_US || zh_CN&#125;&amp;gt;</div><div class="line">				&amp;lt;App /&amp;gt;</div><div class="line">			&amp;lt;/IntlProvider&amp;gt;</div><div class="line">		)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;/code&gt;&lt;/pre&gt;</div><div class="line">你可以把上面的代码再封装成一个组件，不过用法就是这么简单了。</div><div class="line"></div><div class="line">#### 4.通过组件形式使用</div><div class="line">包裹的App组件内的所有子组件都可以直接使用国际化资源[(直接看最全Demo)](https://github.com/yahoo/react-intl/wiki/Components)：</div><div class="line">&lt;pre&gt;&lt;code&gt;import &#123;FormattedMessage /*...*/ &#125; from &apos;react-intl&apos;;</div><div class="line">&amp;lt;FormattedMessage id=&quot;question&quot;/&amp;gt; &lt;!--根据IntlProvider指定locale生成相应的内容--&gt;</div><div class="line">&lt;/code&gt;&lt;/pre&gt;</div><div class="line">需要注意以下几点：</div><div class="line">1. 使用任何的组件都会默认生成&lt;span&gt;xxx&lt;/span&gt;包裹的元素，你也可以指定tagName来使用别的替代，如果你期望不生成包裹元素，可以查阅第5节。  </div><div class="line">2. 通常建议使用 `defaultMessage=&quot;中文内容&quot; ` 来方便前端Debug，这也是蚂蚁官方建议的一种[约定](https://github.com/ant-design/intl-example/blob/master/docs/understanding-antd-i18n.md)  </div><div class="line">3. 通过指定 `id=&quot;xxx&quot; values=&#123;&#123;login :&quot;loginUrl&quot;, regist:&quot;registUrl&quot;&#125;&#125;` 来实现占位符字符串替换的功能，资源文件中需要这样预留占位符 `xxx: &apos;请前往&#123;loginUrl&#125;登录或者前往&#123;registUrl&#125;注册&apos;`  </div><div class="line">4. 像时间、数字，React-Intl已经默认有一些集成好的展示格式了。</div><div class="line"></div><div class="line">#### 5.通过API形式使用</div><div class="line">刚才提到一点，使用组件形式虽然直观，但是很多时候，我们只是想获取实际想要字符串罢了，比如填入&amp;lt;option&amp;gt;标签中，或者喂给一个组件作为properties，这个时候我们需要使用React-Intl提供的另一种API调用形式。</div><div class="line">&lt;pre&gt;&lt;code&gt;//我一般都是在export的时候包装一下</div><div class="line">import &#123; injectIntl &#125; from &apos;react-intl&apos;;</div><div class="line">class SubComponent extends Component &#123;......&#125;</div><div class="line">export default injectIntl(SubComponent);</div><div class="line">&lt;/code&gt;&lt;/pre&gt;</div><div class="line">通过injectIntl实际上是给组件额外的包裹了一层，它的代码非常简单，只有61行，其中大部分是空行或者注释。它的原理其实就是包裹内层的组件，并且把React-Intl的Context下的方法注入到这个内层组件中，就是这一行</div><div class="line">`&#123;...&#123;[intlPropName]: this.context.intl&#125;&#125;`</div><div class="line">然后，我们在这个被包裹的组件中，就可以直接通过类似于`this.props.intl.formatMessage`的方式，像上一节说的进行字符串国际化了，更详细的文档请参考[这里](https://github.com/yahoo/react-intl/wiki/API)。</div><div class="line"></div><div class="line">#### 5.5使用refs</div><div class="line">使用API形式进行包裹组件时，上层的组件是无法通过refs直接拿到子组件的状态和方法的。不过React-Intl也有相应的解决措施，在包裹时需要加如下参数：</div><div class="line">` export default injectIntl(SubComponent, &#123;withRef: true&#125;) `  </div><div class="line">这样的话，父组件可以通过</div><div class="line">` this.refs[&apos;subComponentName&apos;].getWrappedInstance() `</div><div class="line">获取到实际的子组件，这是一个小坑，需要留意。</div><div class="line"></div><div class="line">## 缺点</div><div class="line">#### 1. 资源文件似乎不支持多层嵌套  </div><div class="line">现在[有的React国际化框架](https://github.com/zoover/react-redux-i18n)是支持如下类似的资源文件书写方式:</div></pre></td></tr></table></figure></p>
<p>application : {<br>    block: {<br>        name: ‘QingLuan’<br>    }<br>}<br>```</p>
<p>然后以 <code>id=&quot;application.block.name&quot;</code>的方式直接应用到，而此种写法在React-Intl中无法行的通。我观察了一下React-Intl的Demo、文档和源码，发现React-Intl似乎并不支持这种写法。</p>
<h4 id="2-必须在View层面才可国际化"><a href="#2-必须在View层面才可国际化" class="headerlink" title="2. 必须在View层面才可国际化"></a>2. 必须在View层面才可国际化</h4><p>我们在使用React-Redux框架进行开发的时候，有时候会碰到需要在actions或者reducer层使用字符串的情况(比如包装一个http请求成功的默认方法)，就模块分工的情况来看，数据层也许不应该直接和字符串国际化扯上关系，但是如果一个字符串从View层作为参数流进来的话，代码参数就会显得非常冗余。如果直接使用一个最简单的key-map来做国际化说不定会更简单。</p>
<h4 id="3-React框架一定要使用React国际化方案？"><a href="#3-React框架一定要使用React国际化方案？" class="headerlink" title="3.React框架一定要使用React国际化方案？"></a>3.React框架一定要使用React国际化方案？</h4><p>React-Intl的最大好处，就是在外层的资源文件发生变化时，会自动更新下面的Component，避免了页面的刷新。<br>但是，我们真的需要这样吗？国内几乎找不到这种类型的网站，要么是直接刷新，要么是直接跳转到海外节点，使用React还是其他更为一般化的JavaScript国际化框架，先应该权衡好利弊和代价，再决定使用哪一者。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
